/* soapC.cpp
   Generated by gSOAP 2.8.17r from Markisa.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "stdafx.h"
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.17r 2021-09-24 09:36:20 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_CommandStation:
		return soap_in_CommandStation(soap, NULL, NULL, "CommandStation");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_Processing:
		return soap_in_Processing(soap, NULL, NULL, "Processing");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_hangpacs__CommandStation:
		return soap_in_hangpacs__CommandStation(soap, NULL, NULL, "hangpacs:CommandStation");
	case SOAP_TYPE_hangpacs__FindStation:
		return soap_in_hangpacs__FindStation(soap, NULL, NULL, "hangpacs:FindStation");
	case SOAP_TYPE_hangpacs__ReadLog:
		return soap_in_hangpacs__ReadLog(soap, NULL, NULL, "hangpacs:ReadLog");
	case SOAP_TYPE_hangpacs__WriteLogAsync:
		return soap_in_hangpacs__WriteLogAsync(soap, NULL, NULL, "hangpacs:WriteLogAsync");
	case SOAP_TYPE_hangpacs__WriteLog:
		return soap_in_hangpacs__WriteLog(soap, NULL, NULL, "hangpacs:WriteLog");
	case SOAP_TYPE_hangpacs__FindReceiver:
		return soap_in_hangpacs__FindReceiver(soap, NULL, NULL, "hangpacs:FindReceiver");
	case SOAP_TYPE_hangpacs__RefreshRequest:
		return soap_in_hangpacs__RefreshRequest(soap, NULL, NULL, "hangpacs:RefreshRequest");
	case SOAP_TYPE_hangpacs__ReadRequest:
		return soap_in_hangpacs__ReadRequest(soap, NULL, NULL, "hangpacs:ReadRequest");
	case SOAP_TYPE_hangpacs__WriteRequest:
		return soap_in_hangpacs__WriteRequest(soap, NULL, NULL, "hangpacs:WriteRequest");
	case SOAP_TYPE_csres__CommandStationResponse:
		return soap_in_csres__CommandStationResponse(soap, NULL, NULL, "csres:CommandStationResponse");
	case SOAP_TYPE_CommandStationResponse:
		return soap_in_CommandStationResponse(soap, NULL, NULL, "CommandStationResponse");
	case SOAP_TYPE_csreq__CommandStationRequest:
		return soap_in_csreq__CommandStationRequest(soap, NULL, NULL, "csreq:CommandStationRequest");
	case SOAP_TYPE_CommandStationRequest:
		return soap_in_CommandStationRequest(soap, NULL, NULL, "CommandStationRequest");
	case SOAP_TYPE_fsres__CFindStationResponse:
		return soap_in_fsres__CFindStationResponse(soap, NULL, NULL, "fsres:CFindStationResponse");
	case SOAP_TYPE_FindStationResponse:
		return soap_in_FindStationResponse(soap, NULL, NULL, "FindStationResponse");
	case SOAP_TYPE_fsreq__FindStationRequest:
		return soap_in_fsreq__FindStationRequest(soap, NULL, NULL, "fsreq:FindStationRequest");
	case SOAP_TYPE_FindStationRequest:
		return soap_in_FindStationRequest(soap, NULL, NULL, "FindStationRequest");
	case SOAP_TYPE_rlres__CReadLogResponse:
		return soap_in_rlres__CReadLogResponse(soap, NULL, NULL, "rlres:CReadLogResponse");
	case SOAP_TYPE_ReadLogResponse:
		return soap_in_ReadLogResponse(soap, NULL, NULL, "ReadLogResponse");
	case SOAP_TYPE_rlreq__ReadLogRequest:
		return soap_in_rlreq__ReadLogRequest(soap, NULL, NULL, "rlreq:ReadLogRequest");
	case SOAP_TYPE_ReadLogRequest:
		return soap_in_ReadLogRequest(soap, NULL, NULL, "ReadLogRequest");
	case SOAP_TYPE_wlres__WriteLogResponse:
		return soap_in_wlres__WriteLogResponse(soap, NULL, NULL, "wlres:WriteLogResponse");
	case SOAP_TYPE_WriteLogResponse:
		return soap_in_WriteLogResponse(soap, NULL, NULL, "WriteLogResponse");
	case SOAP_TYPE_wlreq__WriteLogRequest:
		return soap_in_wlreq__WriteLogRequest(soap, NULL, NULL, "wlreq:WriteLogRequest");
	case SOAP_TYPE_WriteLogRequest:
		return soap_in_WriteLogRequest(soap, NULL, NULL, "WriteLogRequest");
	case SOAP_TYPE_frres__FindReceiverResponse:
		return soap_in_frres__FindReceiverResponse(soap, NULL, NULL, "frres:FindReceiverResponse");
	case SOAP_TYPE_FindReceiverResponse:
		return soap_in_FindReceiverResponse(soap, NULL, NULL, "FindReceiverResponse");
	case SOAP_TYPE_frreq__FindReceiverRequest:
		return soap_in_frreq__FindReceiverRequest(soap, NULL, NULL, "frreq:FindReceiverRequest");
	case SOAP_TYPE_FindReceiverRequest:
		return soap_in_FindReceiverRequest(soap, NULL, NULL, "FindReceiverRequest");
	case SOAP_TYPE_rres__RefreshResponse:
		return soap_in_rres__RefreshResponse(soap, NULL, NULL, "rres:RefreshResponse");
	case SOAP_TYPE_RefreshResponse:
		return soap_in_RefreshResponse(soap, NULL, NULL, "RefreshResponse");
	case SOAP_TYPE_rreq__RefreshRequest:
		return soap_in_rreq__RefreshRequest(soap, NULL, NULL, "rreq:RefreshRequest");
	case SOAP_TYPE_RefresRequest:
		return soap_in_RefresRequest(soap, NULL, NULL, "RefresRequest");
	case SOAP_TYPE_rres__CReadResponse:
		return soap_in_rres__CReadResponse(soap, NULL, NULL, "rres:CReadResponse");
	case SOAP_TYPE_rres__ReadResponse:
		return soap_in_rres__ReadResponse(soap, NULL, NULL, "rres:ReadResponse");
	case SOAP_TYPE_ReadResponse:
		return soap_in_ReadResponse(soap, NULL, NULL, "ReadResponse");
	case SOAP_TYPE_rreq__ReadRequest:
		return soap_in_rreq__ReadRequest(soap, NULL, NULL, "rreq:ReadRequest");
	case SOAP_TYPE_ReadRequest:
		return soap_in_ReadRequest(soap, NULL, NULL, "ReadRequest");
	case SOAP_TYPE_wres__WriteResponse:
		return soap_in_wres__WriteResponse(soap, NULL, NULL, "wres:WriteResponse");
	case SOAP_TYPE_WriteResponse:
		return soap_in_WriteResponse(soap, NULL, NULL, "WriteResponse");
	case SOAP_TYPE_wreq__WriteRequest:
		return soap_in_wreq__WriteRequest(soap, NULL, NULL, "wreq:WriteRequest");
	case SOAP_TYPE_WriteRequest:
		return soap_in_WriteRequest(soap, NULL, NULL, "WriteRequest");
	case SOAP_TYPE_PointerTocsres__CommandStationResponse:
		return soap_in_PointerTocsres__CommandStationResponse(soap, NULL, NULL, "csres:CommandStationResponse");
	case SOAP_TYPE_PointerTofsres__CFindStationResponse:
		return soap_in_PointerTofsres__CFindStationResponse(soap, NULL, NULL, "fsres:CFindStationResponse");
	case SOAP_TYPE_PointerTorlres__CReadLogResponse:
		return soap_in_PointerTorlres__CReadLogResponse(soap, NULL, NULL, "rlres:CReadLogResponse");
	case SOAP_TYPE_PointerTowlres__WriteLogResponse:
		return soap_in_PointerTowlres__WriteLogResponse(soap, NULL, NULL, "wlres:WriteLogResponse");
	case SOAP_TYPE_PointerTofrres__FindReceiverResponse:
		return soap_in_PointerTofrres__FindReceiverResponse(soap, NULL, NULL, "frres:FindReceiverResponse");
	case SOAP_TYPE_PointerTorres__RefreshResponse:
		return soap_in_PointerTorres__RefreshResponse(soap, NULL, NULL, "rres:RefreshResponse");
	case SOAP_TYPE_PointerTorres__CReadResponse:
		return soap_in_PointerTorres__CReadResponse(soap, NULL, NULL, "rres:CReadResponse");
	case SOAP_TYPE_PointerTowres__WriteResponse:
		return soap_in_PointerTowres__WriteResponse(soap, NULL, NULL, "wres:WriteResponse");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CommandStation"))
		{	*type = SOAP_TYPE_CommandStation;
			return soap_in_CommandStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Processing"))
		{	*type = SOAP_TYPE_Processing;
			return soap_in_Processing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:CommandStation"))
		{	*type = SOAP_TYPE_hangpacs__CommandStation;
			return soap_in_hangpacs__CommandStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:FindStation"))
		{	*type = SOAP_TYPE_hangpacs__FindStation;
			return soap_in_hangpacs__FindStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:ReadLog"))
		{	*type = SOAP_TYPE_hangpacs__ReadLog;
			return soap_in_hangpacs__ReadLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:WriteLogAsync"))
		{	*type = SOAP_TYPE_hangpacs__WriteLogAsync;
			return soap_in_hangpacs__WriteLogAsync(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:WriteLog"))
		{	*type = SOAP_TYPE_hangpacs__WriteLog;
			return soap_in_hangpacs__WriteLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:FindReceiver"))
		{	*type = SOAP_TYPE_hangpacs__FindReceiver;
			return soap_in_hangpacs__FindReceiver(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:RefreshRequest"))
		{	*type = SOAP_TYPE_hangpacs__RefreshRequest;
			return soap_in_hangpacs__RefreshRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:ReadRequest"))
		{	*type = SOAP_TYPE_hangpacs__ReadRequest;
			return soap_in_hangpacs__ReadRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:WriteRequest"))
		{	*type = SOAP_TYPE_hangpacs__WriteRequest;
			return soap_in_hangpacs__WriteRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "csres:CommandStationResponse"))
		{	*type = SOAP_TYPE_csres__CommandStationResponse;
			return soap_in_csres__CommandStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CommandStationResponse"))
		{	*type = SOAP_TYPE_CommandStationResponse;
			return soap_in_CommandStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "csreq:CommandStationRequest"))
		{	*type = SOAP_TYPE_csreq__CommandStationRequest;
			return soap_in_csreq__CommandStationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CommandStationRequest"))
		{	*type = SOAP_TYPE_CommandStationRequest;
			return soap_in_CommandStationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fsres:CFindStationResponse"))
		{	*type = SOAP_TYPE_fsres__CFindStationResponse;
			return soap_in_fsres__CFindStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "FindStationResponse"))
		{	*type = SOAP_TYPE_FindStationResponse;
			return soap_in_FindStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fsreq:FindStationRequest"))
		{	*type = SOAP_TYPE_fsreq__FindStationRequest;
			return soap_in_fsreq__FindStationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "FindStationRequest"))
		{	*type = SOAP_TYPE_FindStationRequest;
			return soap_in_FindStationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rlres:CReadLogResponse"))
		{	*type = SOAP_TYPE_rlres__CReadLogResponse;
			return soap_in_rlres__CReadLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ReadLogResponse"))
		{	*type = SOAP_TYPE_ReadLogResponse;
			return soap_in_ReadLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rlreq:ReadLogRequest"))
		{	*type = SOAP_TYPE_rlreq__ReadLogRequest;
			return soap_in_rlreq__ReadLogRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ReadLogRequest"))
		{	*type = SOAP_TYPE_ReadLogRequest;
			return soap_in_ReadLogRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wlres:WriteLogResponse"))
		{	*type = SOAP_TYPE_wlres__WriteLogResponse;
			return soap_in_wlres__WriteLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WriteLogResponse"))
		{	*type = SOAP_TYPE_WriteLogResponse;
			return soap_in_WriteLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wlreq:WriteLogRequest"))
		{	*type = SOAP_TYPE_wlreq__WriteLogRequest;
			return soap_in_wlreq__WriteLogRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WriteLogRequest"))
		{	*type = SOAP_TYPE_WriteLogRequest;
			return soap_in_WriteLogRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "frres:FindReceiverResponse"))
		{	*type = SOAP_TYPE_frres__FindReceiverResponse;
			return soap_in_frres__FindReceiverResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "FindReceiverResponse"))
		{	*type = SOAP_TYPE_FindReceiverResponse;
			return soap_in_FindReceiverResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "frreq:FindReceiverRequest"))
		{	*type = SOAP_TYPE_frreq__FindReceiverRequest;
			return soap_in_frreq__FindReceiverRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "FindReceiverRequest"))
		{	*type = SOAP_TYPE_FindReceiverRequest;
			return soap_in_FindReceiverRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rres:RefreshResponse"))
		{	*type = SOAP_TYPE_rres__RefreshResponse;
			return soap_in_rres__RefreshResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "RefreshResponse"))
		{	*type = SOAP_TYPE_RefreshResponse;
			return soap_in_RefreshResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rreq:RefreshRequest"))
		{	*type = SOAP_TYPE_rreq__RefreshRequest;
			return soap_in_rreq__RefreshRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "RefresRequest"))
		{	*type = SOAP_TYPE_RefresRequest;
			return soap_in_RefresRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rres:CReadResponse"))
		{	*type = SOAP_TYPE_rres__CReadResponse;
			return soap_in_rres__CReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rres:ReadResponse"))
		{	*type = SOAP_TYPE_rres__ReadResponse;
			return soap_in_rres__ReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ReadResponse"))
		{	*type = SOAP_TYPE_ReadResponse;
			return soap_in_ReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rreq:ReadRequest"))
		{	*type = SOAP_TYPE_rreq__ReadRequest;
			return soap_in_rreq__ReadRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ReadRequest"))
		{	*type = SOAP_TYPE_ReadRequest;
			return soap_in_ReadRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wres:WriteResponse"))
		{	*type = SOAP_TYPE_wres__WriteResponse;
			return soap_in_wres__WriteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WriteResponse"))
		{	*type = SOAP_TYPE_WriteResponse;
			return soap_in_WriteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wreq:WriteRequest"))
		{	*type = SOAP_TYPE_wreq__WriteRequest;
			return soap_in_wreq__WriteRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WriteRequest"))
		{	*type = SOAP_TYPE_WriteRequest;
			return soap_in_WriteRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "hangpacs:CommandStation"))
		{	*type = SOAP_TYPE__hangpacs__CommandStation;
			return soap_in__hangpacs__CommandStation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "hangpacs:Processing"))
		{	*type = SOAP_TYPE__hangpacs__Processing;
			return soap_in__hangpacs__Processing(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fsres:CFindStationResponse"))
		{	*type = SOAP_TYPE__fsres__CFindStationResponse;
			return soap_in__fsres__CFindStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rlres:CReadLogResponse"))
		{	*type = SOAP_TYPE__rlres__CReadLogResponse;
			return soap_in__rlres__CReadLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rres:CReadResponse"))
		{	*type = SOAP_TYPE__rres__CReadResponse;
			return soap_in__rres__CReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "csres-CommandStationResponse"))
		{	*type = SOAP_TYPE__csres_CommandStationResponse;
			return soap_in__csres_CommandStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "csreq-CommandStationRequest"))
		{	*type = SOAP_TYPE__csreq_CommandStationRequest;
			return soap_in__csreq_CommandStationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fsres-FindStationResponse"))
		{	*type = SOAP_TYPE__fsres_FindStationResponse;
			return soap_in__fsres_FindStationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fsreq-FindStationRequest"))
		{	*type = SOAP_TYPE__fsreq_FindStationRequest;
			return soap_in__fsreq_FindStationRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rlres-ReadLogResponse"))
		{	*type = SOAP_TYPE__rlres_ReadLogResponse;
			return soap_in__rlres_ReadLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rlreq-ReadLogRequest"))
		{	*type = SOAP_TYPE__rlreq_ReadLogRequest;
			return soap_in__rlreq_ReadLogRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wlres-WriteLogResponse"))
		{	*type = SOAP_TYPE__wlres_WriteLogResponse;
			return soap_in__wlres_WriteLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wlreq-WriteLogRequest"))
		{	*type = SOAP_TYPE__wlreq_WriteLogRequest;
			return soap_in__wlreq_WriteLogRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "frres-FindReceiverResponse"))
		{	*type = SOAP_TYPE__frres_FindReceiverResponse;
			return soap_in__frres_FindReceiverResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "frreq-FindReceiverRequest"))
		{	*type = SOAP_TYPE__frreq_FindReceiverRequest;
			return soap_in__frreq_FindReceiverRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rres-RefreshResponse"))
		{	*type = SOAP_TYPE__rres_RefreshResponse;
			return soap_in__rres_RefreshResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rreq-RefresRequest"))
		{	*type = SOAP_TYPE__rreq_RefresRequest;
			return soap_in__rreq_RefresRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rres:ReadResponse"))
		{	*type = SOAP_TYPE__rres__ReadResponse;
			return soap_in__rres__ReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rreq:ReadRequest"))
		{	*type = SOAP_TYPE__rreq__ReadRequest;
			return soap_in__rreq__ReadRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wres:WriteResponse"))
		{	*type = SOAP_TYPE__wres__WriteResponse;
			return soap_in__wres__WriteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wreq:WriteRequest"))
		{	*type = SOAP_TYPE__wreq__WriteRequest;
			return soap_in__wreq__WriteRequest(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__hangpacs__CommandStation:
		return soap_out__hangpacs__CommandStation(soap, "hangpacs:CommandStation", id, (const enum CommandStation *)ptr, NULL);
	case SOAP_TYPE_CommandStation:
		return soap_out_CommandStation(soap, tag, id, (const enum CommandStation *)ptr, "CommandStation");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__hangpacs__Processing:
		return soap_out__hangpacs__Processing(soap, "hangpacs:Processing", id, (const enum Processing *)ptr, NULL);
	case SOAP_TYPE_Processing:
		return soap_out_Processing(soap, tag, id, (const enum Processing *)ptr, "Processing");
	case SOAP_TYPE__fsres__CFindStationResponse:
		return ((_fsres__CFindStationResponse *)ptr)->soap_out(soap, "fsres:CFindStationResponse", id, NULL);
	case SOAP_TYPE__rlres__CReadLogResponse:
		return ((_rlres__CReadLogResponse *)ptr)->soap_out(soap, "rlres:CReadLogResponse", id, NULL);
	case SOAP_TYPE__rres__CReadResponse:
		return ((_rres__CReadResponse *)ptr)->soap_out(soap, "rres:CReadResponse", id, NULL);
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_hangpacs__CommandStation:
		return soap_out_hangpacs__CommandStation(soap, tag, id, (const struct hangpacs__CommandStation *)ptr, "hangpacs:CommandStation");
	case SOAP_TYPE_hangpacs__FindStation:
		return soap_out_hangpacs__FindStation(soap, tag, id, (const struct hangpacs__FindStation *)ptr, "hangpacs:FindStation");
	case SOAP_TYPE_hangpacs__ReadLog:
		return soap_out_hangpacs__ReadLog(soap, tag, id, (const struct hangpacs__ReadLog *)ptr, "hangpacs:ReadLog");
	case SOAP_TYPE_hangpacs__WriteLogAsync:
		return soap_out_hangpacs__WriteLogAsync(soap, tag, id, (const struct hangpacs__WriteLogAsync *)ptr, "hangpacs:WriteLogAsync");
	case SOAP_TYPE_hangpacs__WriteLog:
		return soap_out_hangpacs__WriteLog(soap, tag, id, (const struct hangpacs__WriteLog *)ptr, "hangpacs:WriteLog");
	case SOAP_TYPE_hangpacs__FindReceiver:
		return soap_out_hangpacs__FindReceiver(soap, tag, id, (const struct hangpacs__FindReceiver *)ptr, "hangpacs:FindReceiver");
	case SOAP_TYPE_hangpacs__RefreshRequest:
		return soap_out_hangpacs__RefreshRequest(soap, tag, id, (const struct hangpacs__RefreshRequest *)ptr, "hangpacs:RefreshRequest");
	case SOAP_TYPE_hangpacs__ReadRequest:
		return soap_out_hangpacs__ReadRequest(soap, tag, id, (const struct hangpacs__ReadRequest *)ptr, "hangpacs:ReadRequest");
	case SOAP_TYPE_hangpacs__WriteRequest:
		return soap_out_hangpacs__WriteRequest(soap, tag, id, (const struct hangpacs__WriteRequest *)ptr, "hangpacs:WriteRequest");
	case SOAP_TYPE_csres__CommandStationResponse:
		return soap_out_csres__CommandStationResponse(soap, tag, id, (const struct csres__CommandStationResponse *)ptr, "csres:CommandStationResponse");
	case SOAP_TYPE__csres_CommandStationResponse:
		return soap_out__csres_CommandStationResponse(soap, "csres-CommandStationResponse", id, (const struct CommandStationResponse *)ptr, NULL);
	case SOAP_TYPE_CommandStationResponse:
		return soap_out_CommandStationResponse(soap, tag, id, (const struct CommandStationResponse *)ptr, "CommandStationResponse");
	case SOAP_TYPE_csreq__CommandStationRequest:
		return soap_out_csreq__CommandStationRequest(soap, tag, id, (const struct csreq__CommandStationRequest *)ptr, "csreq:CommandStationRequest");
	case SOAP_TYPE__csreq_CommandStationRequest:
		return soap_out__csreq_CommandStationRequest(soap, "csreq-CommandStationRequest", id, (const struct CommandStationRequest *)ptr, NULL);
	case SOAP_TYPE_CommandStationRequest:
		return soap_out_CommandStationRequest(soap, tag, id, (const struct CommandStationRequest *)ptr, "CommandStationRequest");
	case SOAP_TYPE_fsres__CFindStationResponse:
		return soap_out_fsres__CFindStationResponse(soap, tag, id, (const struct fsres__CFindStationResponse *)ptr, "fsres:CFindStationResponse");
	case SOAP_TYPE__fsres_FindStationResponse:
		return soap_out__fsres_FindStationResponse(soap, "fsres-FindStationResponse", id, (const struct FindStationResponse *)ptr, NULL);
	case SOAP_TYPE_FindStationResponse:
		return soap_out_FindStationResponse(soap, tag, id, (const struct FindStationResponse *)ptr, "FindStationResponse");
	case SOAP_TYPE_fsreq__FindStationRequest:
		return soap_out_fsreq__FindStationRequest(soap, tag, id, (const struct fsreq__FindStationRequest *)ptr, "fsreq:FindStationRequest");
	case SOAP_TYPE__fsreq_FindStationRequest:
		return soap_out__fsreq_FindStationRequest(soap, "fsreq-FindStationRequest", id, (const struct FindStationRequest *)ptr, NULL);
	case SOAP_TYPE_FindStationRequest:
		return soap_out_FindStationRequest(soap, tag, id, (const struct FindStationRequest *)ptr, "FindStationRequest");
	case SOAP_TYPE_rlres__CReadLogResponse:
		return soap_out_rlres__CReadLogResponse(soap, tag, id, (const struct rlres__CReadLogResponse *)ptr, "rlres:CReadLogResponse");
	case SOAP_TYPE__rlres_ReadLogResponse:
		return soap_out__rlres_ReadLogResponse(soap, "rlres-ReadLogResponse", id, (const struct ReadLogResponse *)ptr, NULL);
	case SOAP_TYPE_ReadLogResponse:
		return soap_out_ReadLogResponse(soap, tag, id, (const struct ReadLogResponse *)ptr, "ReadLogResponse");
	case SOAP_TYPE_rlreq__ReadLogRequest:
		return soap_out_rlreq__ReadLogRequest(soap, tag, id, (const struct rlreq__ReadLogRequest *)ptr, "rlreq:ReadLogRequest");
	case SOAP_TYPE__rlreq_ReadLogRequest:
		return soap_out__rlreq_ReadLogRequest(soap, "rlreq-ReadLogRequest", id, (const struct ReadLogRequest *)ptr, NULL);
	case SOAP_TYPE_ReadLogRequest:
		return soap_out_ReadLogRequest(soap, tag, id, (const struct ReadLogRequest *)ptr, "ReadLogRequest");
	case SOAP_TYPE_wlres__WriteLogResponse:
		return soap_out_wlres__WriteLogResponse(soap, tag, id, (const struct wlres__WriteLogResponse *)ptr, "wlres:WriteLogResponse");
	case SOAP_TYPE__wlres_WriteLogResponse:
		return soap_out__wlres_WriteLogResponse(soap, "wlres-WriteLogResponse", id, (const struct WriteLogResponse *)ptr, NULL);
	case SOAP_TYPE_WriteLogResponse:
		return soap_out_WriteLogResponse(soap, tag, id, (const struct WriteLogResponse *)ptr, "WriteLogResponse");
	case SOAP_TYPE_wlreq__WriteLogRequest:
		return soap_out_wlreq__WriteLogRequest(soap, tag, id, (const struct wlreq__WriteLogRequest *)ptr, "wlreq:WriteLogRequest");
	case SOAP_TYPE__wlreq_WriteLogRequest:
		return soap_out__wlreq_WriteLogRequest(soap, "wlreq-WriteLogRequest", id, (const struct WriteLogRequest *)ptr, NULL);
	case SOAP_TYPE_WriteLogRequest:
		return soap_out_WriteLogRequest(soap, tag, id, (const struct WriteLogRequest *)ptr, "WriteLogRequest");
	case SOAP_TYPE_frres__FindReceiverResponse:
		return soap_out_frres__FindReceiverResponse(soap, tag, id, (const struct frres__FindReceiverResponse *)ptr, "frres:FindReceiverResponse");
	case SOAP_TYPE__frres_FindReceiverResponse:
		return soap_out__frres_FindReceiverResponse(soap, "frres-FindReceiverResponse", id, (const struct FindReceiverResponse *)ptr, NULL);
	case SOAP_TYPE_FindReceiverResponse:
		return soap_out_FindReceiverResponse(soap, tag, id, (const struct FindReceiverResponse *)ptr, "FindReceiverResponse");
	case SOAP_TYPE_frreq__FindReceiverRequest:
		return soap_out_frreq__FindReceiverRequest(soap, tag, id, (const struct frreq__FindReceiverRequest *)ptr, "frreq:FindReceiverRequest");
	case SOAP_TYPE__frreq_FindReceiverRequest:
		return soap_out__frreq_FindReceiverRequest(soap, "frreq-FindReceiverRequest", id, (const struct FindReceiverRequest *)ptr, NULL);
	case SOAP_TYPE_FindReceiverRequest:
		return soap_out_FindReceiverRequest(soap, tag, id, (const struct FindReceiverRequest *)ptr, "FindReceiverRequest");
	case SOAP_TYPE_rres__RefreshResponse:
		return soap_out_rres__RefreshResponse(soap, tag, id, (const struct rres__RefreshResponse *)ptr, "rres:RefreshResponse");
	case SOAP_TYPE__rres_RefreshResponse:
		return soap_out__rres_RefreshResponse(soap, "rres-RefreshResponse", id, (const struct RefreshResponse *)ptr, NULL);
	case SOAP_TYPE_RefreshResponse:
		return soap_out_RefreshResponse(soap, tag, id, (const struct RefreshResponse *)ptr, "RefreshResponse");
	case SOAP_TYPE_rreq__RefreshRequest:
		return soap_out_rreq__RefreshRequest(soap, tag, id, (const struct rreq__RefreshRequest *)ptr, "rreq:RefreshRequest");
	case SOAP_TYPE__rreq_RefresRequest:
		return soap_out__rreq_RefresRequest(soap, "rreq-RefresRequest", id, (const struct RefresRequest *)ptr, NULL);
	case SOAP_TYPE_RefresRequest:
		return soap_out_RefresRequest(soap, tag, id, (const struct RefresRequest *)ptr, "RefresRequest");
	case SOAP_TYPE_rres__CReadResponse:
		return soap_out_rres__CReadResponse(soap, tag, id, (const struct rres__CReadResponse *)ptr, "rres:CReadResponse");
	case SOAP_TYPE_rres__ReadResponse:
		return soap_out_rres__ReadResponse(soap, tag, id, (const struct rres__ReadResponse *)ptr, "rres:ReadResponse");
	case SOAP_TYPE__rres__ReadResponse:
		return soap_out__rres__ReadResponse(soap, "rres:ReadResponse", id, (const struct ReadResponse *)ptr, NULL);
	case SOAP_TYPE_ReadResponse:
		return soap_out_ReadResponse(soap, tag, id, (const struct ReadResponse *)ptr, "ReadResponse");
	case SOAP_TYPE_rreq__ReadRequest:
		return soap_out_rreq__ReadRequest(soap, tag, id, (const struct rreq__ReadRequest *)ptr, "rreq:ReadRequest");
	case SOAP_TYPE__rreq__ReadRequest:
		return soap_out__rreq__ReadRequest(soap, "rreq:ReadRequest", id, (const struct ReadRequest *)ptr, NULL);
	case SOAP_TYPE_ReadRequest:
		return soap_out_ReadRequest(soap, tag, id, (const struct ReadRequest *)ptr, "ReadRequest");
	case SOAP_TYPE_wres__WriteResponse:
		return soap_out_wres__WriteResponse(soap, tag, id, (const struct wres__WriteResponse *)ptr, "wres:WriteResponse");
	case SOAP_TYPE__wres__WriteResponse:
		return soap_out__wres__WriteResponse(soap, "wres:WriteResponse", id, (const struct WriteResponse *)ptr, NULL);
	case SOAP_TYPE_WriteResponse:
		return soap_out_WriteResponse(soap, tag, id, (const struct WriteResponse *)ptr, "WriteResponse");
	case SOAP_TYPE_wreq__WriteRequest:
		return soap_out_wreq__WriteRequest(soap, tag, id, (const struct wreq__WriteRequest *)ptr, "wreq:WriteRequest");
	case SOAP_TYPE__wreq__WriteRequest:
		return soap_out__wreq__WriteRequest(soap, "wreq:WriteRequest", id, (const struct WriteRequest *)ptr, NULL);
	case SOAP_TYPE_WriteRequest:
		return soap_out_WriteRequest(soap, tag, id, (const struct WriteRequest *)ptr, "WriteRequest");
	case SOAP_TYPE_PointerTocsres__CommandStationResponse:
		return soap_out_PointerTocsres__CommandStationResponse(soap, tag, id, (struct csres__CommandStationResponse *const*)ptr, "csres:CommandStationResponse");
	case SOAP_TYPE_PointerTofsres__CFindStationResponse:
		return soap_out_PointerTofsres__CFindStationResponse(soap, tag, id, (struct fsres__CFindStationResponse *const*)ptr, "fsres:CFindStationResponse");
	case SOAP_TYPE_PointerTorlres__CReadLogResponse:
		return soap_out_PointerTorlres__CReadLogResponse(soap, tag, id, (struct rlres__CReadLogResponse *const*)ptr, "rlres:CReadLogResponse");
	case SOAP_TYPE_PointerTowlres__WriteLogResponse:
		return soap_out_PointerTowlres__WriteLogResponse(soap, tag, id, (struct wlres__WriteLogResponse *const*)ptr, "wlres:WriteLogResponse");
	case SOAP_TYPE_PointerTofrres__FindReceiverResponse:
		return soap_out_PointerTofrres__FindReceiverResponse(soap, tag, id, (struct frres__FindReceiverResponse *const*)ptr, "frres:FindReceiverResponse");
	case SOAP_TYPE_PointerTorres__RefreshResponse:
		return soap_out_PointerTorres__RefreshResponse(soap, tag, id, (struct rres__RefreshResponse *const*)ptr, "rres:RefreshResponse");
	case SOAP_TYPE_PointerTorres__CReadResponse:
		return soap_out_PointerTorres__CReadResponse(soap, tag, id, (struct rres__CReadResponse *const*)ptr, "rres:CReadResponse");
	case SOAP_TYPE_PointerTowres__WriteResponse:
		return soap_out_PointerTowres__WriteResponse(soap, tag, id, (struct wres__WriteResponse *const*)ptr, "wres:WriteResponse");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__fsres__CFindStationResponse:
		((_fsres__CFindStationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__rlres__CReadLogResponse:
		((_rlres__CReadLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__rres__CReadResponse:
		((_rres__CReadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_hangpacs__CommandStation:
		soap_serialize_hangpacs__CommandStation(soap, (const struct hangpacs__CommandStation *)ptr);
		break;
	case SOAP_TYPE_hangpacs__FindStation:
		soap_serialize_hangpacs__FindStation(soap, (const struct hangpacs__FindStation *)ptr);
		break;
	case SOAP_TYPE_hangpacs__ReadLog:
		soap_serialize_hangpacs__ReadLog(soap, (const struct hangpacs__ReadLog *)ptr);
		break;
	case SOAP_TYPE_hangpacs__WriteLogAsync:
		soap_serialize_hangpacs__WriteLogAsync(soap, (const struct hangpacs__WriteLogAsync *)ptr);
		break;
	case SOAP_TYPE_hangpacs__WriteLog:
		soap_serialize_hangpacs__WriteLog(soap, (const struct hangpacs__WriteLog *)ptr);
		break;
	case SOAP_TYPE_hangpacs__FindReceiver:
		soap_serialize_hangpacs__FindReceiver(soap, (const struct hangpacs__FindReceiver *)ptr);
		break;
	case SOAP_TYPE_hangpacs__RefreshRequest:
		soap_serialize_hangpacs__RefreshRequest(soap, (const struct hangpacs__RefreshRequest *)ptr);
		break;
	case SOAP_TYPE_hangpacs__ReadRequest:
		soap_serialize_hangpacs__ReadRequest(soap, (const struct hangpacs__ReadRequest *)ptr);
		break;
	case SOAP_TYPE_hangpacs__WriteRequest:
		soap_serialize_hangpacs__WriteRequest(soap, (const struct hangpacs__WriteRequest *)ptr);
		break;
	case SOAP_TYPE_csres__CommandStationResponse:
		soap_serialize_csres__CommandStationResponse(soap, (const struct csres__CommandStationResponse *)ptr);
		break;
	case SOAP_TYPE__csres_CommandStationResponse:
		soap_serialize__csres_CommandStationResponse(soap, (const struct CommandStationResponse *)ptr);
		break;
	case SOAP_TYPE_CommandStationResponse:
		soap_serialize_CommandStationResponse(soap, (const struct CommandStationResponse *)ptr);
		break;
	case SOAP_TYPE_csreq__CommandStationRequest:
		soap_serialize_csreq__CommandStationRequest(soap, (const struct csreq__CommandStationRequest *)ptr);
		break;
	case SOAP_TYPE__csreq_CommandStationRequest:
		soap_serialize__csreq_CommandStationRequest(soap, (const struct CommandStationRequest *)ptr);
		break;
	case SOAP_TYPE_CommandStationRequest:
		soap_serialize_CommandStationRequest(soap, (const struct CommandStationRequest *)ptr);
		break;
	case SOAP_TYPE_fsres__CFindStationResponse:
		soap_serialize_fsres__CFindStationResponse(soap, (const struct fsres__CFindStationResponse *)ptr);
		break;
	case SOAP_TYPE__fsres_FindStationResponse:
		soap_serialize__fsres_FindStationResponse(soap, (const struct FindStationResponse *)ptr);
		break;
	case SOAP_TYPE_FindStationResponse:
		soap_serialize_FindStationResponse(soap, (const struct FindStationResponse *)ptr);
		break;
	case SOAP_TYPE_fsreq__FindStationRequest:
		soap_serialize_fsreq__FindStationRequest(soap, (const struct fsreq__FindStationRequest *)ptr);
		break;
	case SOAP_TYPE__fsreq_FindStationRequest:
		soap_serialize__fsreq_FindStationRequest(soap, (const struct FindStationRequest *)ptr);
		break;
	case SOAP_TYPE_FindStationRequest:
		soap_serialize_FindStationRequest(soap, (const struct FindStationRequest *)ptr);
		break;
	case SOAP_TYPE_rlres__CReadLogResponse:
		soap_serialize_rlres__CReadLogResponse(soap, (const struct rlres__CReadLogResponse *)ptr);
		break;
	case SOAP_TYPE__rlres_ReadLogResponse:
		soap_serialize__rlres_ReadLogResponse(soap, (const struct ReadLogResponse *)ptr);
		break;
	case SOAP_TYPE_ReadLogResponse:
		soap_serialize_ReadLogResponse(soap, (const struct ReadLogResponse *)ptr);
		break;
	case SOAP_TYPE_rlreq__ReadLogRequest:
		soap_serialize_rlreq__ReadLogRequest(soap, (const struct rlreq__ReadLogRequest *)ptr);
		break;
	case SOAP_TYPE__rlreq_ReadLogRequest:
		soap_serialize__rlreq_ReadLogRequest(soap, (const struct ReadLogRequest *)ptr);
		break;
	case SOAP_TYPE_ReadLogRequest:
		soap_serialize_ReadLogRequest(soap, (const struct ReadLogRequest *)ptr);
		break;
	case SOAP_TYPE_wlres__WriteLogResponse:
		soap_serialize_wlres__WriteLogResponse(soap, (const struct wlres__WriteLogResponse *)ptr);
		break;
	case SOAP_TYPE__wlres_WriteLogResponse:
		soap_serialize__wlres_WriteLogResponse(soap, (const struct WriteLogResponse *)ptr);
		break;
	case SOAP_TYPE_WriteLogResponse:
		soap_serialize_WriteLogResponse(soap, (const struct WriteLogResponse *)ptr);
		break;
	case SOAP_TYPE_wlreq__WriteLogRequest:
		soap_serialize_wlreq__WriteLogRequest(soap, (const struct wlreq__WriteLogRequest *)ptr);
		break;
	case SOAP_TYPE__wlreq_WriteLogRequest:
		soap_serialize__wlreq_WriteLogRequest(soap, (const struct WriteLogRequest *)ptr);
		break;
	case SOAP_TYPE_WriteLogRequest:
		soap_serialize_WriteLogRequest(soap, (const struct WriteLogRequest *)ptr);
		break;
	case SOAP_TYPE_frres__FindReceiverResponse:
		soap_serialize_frres__FindReceiverResponse(soap, (const struct frres__FindReceiverResponse *)ptr);
		break;
	case SOAP_TYPE__frres_FindReceiverResponse:
		soap_serialize__frres_FindReceiverResponse(soap, (const struct FindReceiverResponse *)ptr);
		break;
	case SOAP_TYPE_FindReceiverResponse:
		soap_serialize_FindReceiverResponse(soap, (const struct FindReceiverResponse *)ptr);
		break;
	case SOAP_TYPE_frreq__FindReceiverRequest:
		soap_serialize_frreq__FindReceiverRequest(soap, (const struct frreq__FindReceiverRequest *)ptr);
		break;
	case SOAP_TYPE__frreq_FindReceiverRequest:
		soap_serialize__frreq_FindReceiverRequest(soap, (const struct FindReceiverRequest *)ptr);
		break;
	case SOAP_TYPE_FindReceiverRequest:
		soap_serialize_FindReceiverRequest(soap, (const struct FindReceiverRequest *)ptr);
		break;
	case SOAP_TYPE_rres__RefreshResponse:
		soap_serialize_rres__RefreshResponse(soap, (const struct rres__RefreshResponse *)ptr);
		break;
	case SOAP_TYPE__rres_RefreshResponse:
		soap_serialize__rres_RefreshResponse(soap, (const struct RefreshResponse *)ptr);
		break;
	case SOAP_TYPE_RefreshResponse:
		soap_serialize_RefreshResponse(soap, (const struct RefreshResponse *)ptr);
		break;
	case SOAP_TYPE_rreq__RefreshRequest:
		soap_serialize_rreq__RefreshRequest(soap, (const struct rreq__RefreshRequest *)ptr);
		break;
	case SOAP_TYPE__rreq_RefresRequest:
		soap_serialize__rreq_RefresRequest(soap, (const struct RefresRequest *)ptr);
		break;
	case SOAP_TYPE_RefresRequest:
		soap_serialize_RefresRequest(soap, (const struct RefresRequest *)ptr);
		break;
	case SOAP_TYPE_rres__CReadResponse:
		soap_serialize_rres__CReadResponse(soap, (const struct rres__CReadResponse *)ptr);
		break;
	case SOAP_TYPE_rres__ReadResponse:
		soap_serialize_rres__ReadResponse(soap, (const struct rres__ReadResponse *)ptr);
		break;
	case SOAP_TYPE__rres__ReadResponse:
		soap_serialize__rres__ReadResponse(soap, (const struct ReadResponse *)ptr);
		break;
	case SOAP_TYPE_ReadResponse:
		soap_serialize_ReadResponse(soap, (const struct ReadResponse *)ptr);
		break;
	case SOAP_TYPE_rreq__ReadRequest:
		soap_serialize_rreq__ReadRequest(soap, (const struct rreq__ReadRequest *)ptr);
		break;
	case SOAP_TYPE__rreq__ReadRequest:
		soap_serialize__rreq__ReadRequest(soap, (const struct ReadRequest *)ptr);
		break;
	case SOAP_TYPE_ReadRequest:
		soap_serialize_ReadRequest(soap, (const struct ReadRequest *)ptr);
		break;
	case SOAP_TYPE_wres__WriteResponse:
		soap_serialize_wres__WriteResponse(soap, (const struct wres__WriteResponse *)ptr);
		break;
	case SOAP_TYPE__wres__WriteResponse:
		soap_serialize__wres__WriteResponse(soap, (const struct WriteResponse *)ptr);
		break;
	case SOAP_TYPE_WriteResponse:
		soap_serialize_WriteResponse(soap, (const struct WriteResponse *)ptr);
		break;
	case SOAP_TYPE_wreq__WriteRequest:
		soap_serialize_wreq__WriteRequest(soap, (const struct wreq__WriteRequest *)ptr);
		break;
	case SOAP_TYPE__wreq__WriteRequest:
		soap_serialize__wreq__WriteRequest(soap, (const struct WriteRequest *)ptr);
		break;
	case SOAP_TYPE_WriteRequest:
		soap_serialize_WriteRequest(soap, (const struct WriteRequest *)ptr);
		break;
	case SOAP_TYPE_PointerTocsres__CommandStationResponse:
		soap_serialize_PointerTocsres__CommandStationResponse(soap, (struct csres__CommandStationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofsres__CFindStationResponse:
		soap_serialize_PointerTofsres__CFindStationResponse(soap, (struct fsres__CFindStationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorlres__CReadLogResponse:
		soap_serialize_PointerTorlres__CReadLogResponse(soap, (struct rlres__CReadLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowlres__WriteLogResponse:
		soap_serialize_PointerTowlres__WriteLogResponse(soap, (struct wlres__WriteLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofrres__FindReceiverResponse:
		soap_serialize_PointerTofrres__FindReceiverResponse(soap, (struct frres__FindReceiverResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorres__RefreshResponse:
		soap_serialize_PointerTorres__RefreshResponse(soap, (struct rres__RefreshResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorres__CReadResponse:
		soap_serialize_PointerTorres__CReadResponse(soap, (struct rres__CReadResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowres__WriteResponse:
		soap_serialize_PointerTowres__WriteResponse(soap, (struct wres__WriteResponse *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WriteRequest:
		return (void*)soap_instantiate_WriteRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wreq__WriteRequest:
		return (void*)soap_instantiate_wreq__WriteRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WriteResponse:
		return (void*)soap_instantiate_WriteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wres__WriteResponse:
		return (void*)soap_instantiate_wres__WriteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ReadRequest:
		return (void*)soap_instantiate_ReadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_rreq__ReadRequest:
		return (void*)soap_instantiate_rreq__ReadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ReadResponse:
		return (void*)soap_instantiate_ReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_rres__ReadResponse:
		return (void*)soap_instantiate_rres__ReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__rres__CReadResponse:
		return (void*)soap_instantiate__rres__CReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_rres__CReadResponse:
		return (void*)soap_instantiate_rres__CReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RefresRequest:
		return (void*)soap_instantiate_RefresRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_rreq__RefreshRequest:
		return (void*)soap_instantiate_rreq__RefreshRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_RefreshResponse:
		return (void*)soap_instantiate_RefreshResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_rres__RefreshResponse:
		return (void*)soap_instantiate_rres__RefreshResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FindReceiverRequest:
		return (void*)soap_instantiate_FindReceiverRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_frreq__FindReceiverRequest:
		return (void*)soap_instantiate_frreq__FindReceiverRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FindReceiverResponse:
		return (void*)soap_instantiate_FindReceiverResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_frres__FindReceiverResponse:
		return (void*)soap_instantiate_frres__FindReceiverResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WriteLogRequest:
		return (void*)soap_instantiate_WriteLogRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wlreq__WriteLogRequest:
		return (void*)soap_instantiate_wlreq__WriteLogRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WriteLogResponse:
		return (void*)soap_instantiate_WriteLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wlres__WriteLogResponse:
		return (void*)soap_instantiate_wlres__WriteLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ReadLogRequest:
		return (void*)soap_instantiate_ReadLogRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_rlreq__ReadLogRequest:
		return (void*)soap_instantiate_rlreq__ReadLogRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ReadLogResponse:
		return (void*)soap_instantiate_ReadLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__rlres__CReadLogResponse:
		return (void*)soap_instantiate__rlres__CReadLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_rlres__CReadLogResponse:
		return (void*)soap_instantiate_rlres__CReadLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FindStationRequest:
		return (void*)soap_instantiate_FindStationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fsreq__FindStationRequest:
		return (void*)soap_instantiate_fsreq__FindStationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FindStationResponse:
		return (void*)soap_instantiate_FindStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fsres__CFindStationResponse:
		return (void*)soap_instantiate__fsres__CFindStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fsres__CFindStationResponse:
		return (void*)soap_instantiate_fsres__CFindStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CommandStationRequest:
		return (void*)soap_instantiate_CommandStationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_csreq__CommandStationRequest:
		return (void*)soap_instantiate_csreq__CommandStationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CommandStationResponse:
		return (void*)soap_instantiate_CommandStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_csres__CommandStationResponse:
		return (void*)soap_instantiate_csres__CommandStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_hangpacs__WriteRequest:
		return (void*)soap_instantiate_hangpacs__WriteRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_hangpacs__ReadRequest:
		return (void*)soap_instantiate_hangpacs__ReadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_hangpacs__RefreshRequest:
		return (void*)soap_instantiate_hangpacs__RefreshRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_hangpacs__FindReceiver:
		return (void*)soap_instantiate_hangpacs__FindReceiver(soap, -1, type, arrayType, n);
	case SOAP_TYPE_hangpacs__WriteLog:
		return (void*)soap_instantiate_hangpacs__WriteLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_hangpacs__WriteLogAsync:
		return (void*)soap_instantiate_hangpacs__WriteLogAsync(soap, -1, type, arrayType, n);
	case SOAP_TYPE_hangpacs__ReadLog:
		return (void*)soap_instantiate_hangpacs__ReadLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_hangpacs__FindStation:
		return (void*)soap_instantiate_hangpacs__FindStation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_hangpacs__CommandStation:
		return (void*)soap_instantiate_hangpacs__CommandStation(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE__wreq__WriteRequest:
		return (void*)soap_instantiate__wreq__WriteRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wres__WriteResponse:
		return (void*)soap_instantiate__wres__WriteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__rreq__ReadRequest:
		return (void*)soap_instantiate__rreq__ReadRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__rres__ReadResponse:
		return (void*)soap_instantiate__rres__ReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__rreq_RefresRequest:
		return (void*)soap_instantiate__rreq_RefresRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__rres_RefreshResponse:
		return (void*)soap_instantiate__rres_RefreshResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__frreq_FindReceiverRequest:
		return (void*)soap_instantiate__frreq_FindReceiverRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__frres_FindReceiverResponse:
		return (void*)soap_instantiate__frres_FindReceiverResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wlreq_WriteLogRequest:
		return (void*)soap_instantiate__wlreq_WriteLogRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wlres_WriteLogResponse:
		return (void*)soap_instantiate__wlres_WriteLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__rlreq_ReadLogRequest:
		return (void*)soap_instantiate__rlreq_ReadLogRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__rlres_ReadLogResponse:
		return (void*)soap_instantiate__rlres_ReadLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fsreq_FindStationRequest:
		return (void*)soap_instantiate__fsreq_FindStationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fsres_FindStationResponse:
		return (void*)soap_instantiate__fsres_FindStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__csreq_CommandStationRequest:
		return (void*)soap_instantiate__csreq_CommandStationRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__csres_CommandStationResponse:
		return (void*)soap_instantiate__csres_CommandStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__listTemplateOf_fsres_FindStationResponse:
		return (void*)soap_instantiate_std__listTemplateOf_fsres_FindStationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__listTemplateOf_rlres_ReadLogResponse:
		return (void*)soap_instantiate_std__listTemplateOf_rlres_ReadLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__listTemplateOfstd__wstring:
		return (void*)soap_instantiate_std__listTemplateOfstd__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__listTemplateOf_rres__ReadResponse:
		return (void*)soap_instantiate_std__listTemplateOf_rres__ReadResponse(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_WriteRequest:
		if (p->size < 0)
			SOAP_DELETE((struct WriteRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct WriteRequest*)p->ptr);
		break;
	case SOAP_TYPE_wreq__WriteRequest:
		if (p->size < 0)
			SOAP_DELETE((struct wreq__WriteRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wreq__WriteRequest*)p->ptr);
		break;
	case SOAP_TYPE_WriteResponse:
		if (p->size < 0)
			SOAP_DELETE((struct WriteResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct WriteResponse*)p->ptr);
		break;
	case SOAP_TYPE_wres__WriteResponse:
		if (p->size < 0)
			SOAP_DELETE((struct wres__WriteResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wres__WriteResponse*)p->ptr);
		break;
	case SOAP_TYPE_ReadRequest:
		if (p->size < 0)
			SOAP_DELETE((struct ReadRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReadRequest*)p->ptr);
		break;
	case SOAP_TYPE_rreq__ReadRequest:
		if (p->size < 0)
			SOAP_DELETE((struct rreq__ReadRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct rreq__ReadRequest*)p->ptr);
		break;
	case SOAP_TYPE_ReadResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ReadResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReadResponse*)p->ptr);
		break;
	case SOAP_TYPE_rres__ReadResponse:
		if (p->size < 0)
			SOAP_DELETE((struct rres__ReadResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct rres__ReadResponse*)p->ptr);
		break;
	case SOAP_TYPE__rres__CReadResponse:
		if (p->size < 0)
			SOAP_DELETE((_rres__CReadResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_rres__CReadResponse*)p->ptr);
		break;
	case SOAP_TYPE_rres__CReadResponse:
		if (p->size < 0)
			SOAP_DELETE((struct rres__CReadResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct rres__CReadResponse*)p->ptr);
		break;
	case SOAP_TYPE_RefresRequest:
		if (p->size < 0)
			SOAP_DELETE((struct RefresRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct RefresRequest*)p->ptr);
		break;
	case SOAP_TYPE_rreq__RefreshRequest:
		if (p->size < 0)
			SOAP_DELETE((struct rreq__RefreshRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct rreq__RefreshRequest*)p->ptr);
		break;
	case SOAP_TYPE_RefreshResponse:
		if (p->size < 0)
			SOAP_DELETE((struct RefreshResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct RefreshResponse*)p->ptr);
		break;
	case SOAP_TYPE_rres__RefreshResponse:
		if (p->size < 0)
			SOAP_DELETE((struct rres__RefreshResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct rres__RefreshResponse*)p->ptr);
		break;
	case SOAP_TYPE_FindReceiverRequest:
		if (p->size < 0)
			SOAP_DELETE((struct FindReceiverRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct FindReceiverRequest*)p->ptr);
		break;
	case SOAP_TYPE_frreq__FindReceiverRequest:
		if (p->size < 0)
			SOAP_DELETE((struct frreq__FindReceiverRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct frreq__FindReceiverRequest*)p->ptr);
		break;
	case SOAP_TYPE_FindReceiverResponse:
		if (p->size < 0)
			SOAP_DELETE((struct FindReceiverResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct FindReceiverResponse*)p->ptr);
		break;
	case SOAP_TYPE_frres__FindReceiverResponse:
		if (p->size < 0)
			SOAP_DELETE((struct frres__FindReceiverResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct frres__FindReceiverResponse*)p->ptr);
		break;
	case SOAP_TYPE_WriteLogRequest:
		if (p->size < 0)
			SOAP_DELETE((struct WriteLogRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct WriteLogRequest*)p->ptr);
		break;
	case SOAP_TYPE_wlreq__WriteLogRequest:
		if (p->size < 0)
			SOAP_DELETE((struct wlreq__WriteLogRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wlreq__WriteLogRequest*)p->ptr);
		break;
	case SOAP_TYPE_WriteLogResponse:
		if (p->size < 0)
			SOAP_DELETE((struct WriteLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct WriteLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_wlres__WriteLogResponse:
		if (p->size < 0)
			SOAP_DELETE((struct wlres__WriteLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wlres__WriteLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_ReadLogRequest:
		if (p->size < 0)
			SOAP_DELETE((struct ReadLogRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReadLogRequest*)p->ptr);
		break;
	case SOAP_TYPE_rlreq__ReadLogRequest:
		if (p->size < 0)
			SOAP_DELETE((struct rlreq__ReadLogRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct rlreq__ReadLogRequest*)p->ptr);
		break;
	case SOAP_TYPE_ReadLogResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ReadLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReadLogResponse*)p->ptr);
		break;
	case SOAP_TYPE__rlres__CReadLogResponse:
		if (p->size < 0)
			SOAP_DELETE((_rlres__CReadLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_rlres__CReadLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_rlres__CReadLogResponse:
		if (p->size < 0)
			SOAP_DELETE((struct rlres__CReadLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct rlres__CReadLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_FindStationRequest:
		if (p->size < 0)
			SOAP_DELETE((struct FindStationRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct FindStationRequest*)p->ptr);
		break;
	case SOAP_TYPE_fsreq__FindStationRequest:
		if (p->size < 0)
			SOAP_DELETE((struct fsreq__FindStationRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct fsreq__FindStationRequest*)p->ptr);
		break;
	case SOAP_TYPE_FindStationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct FindStationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct FindStationResponse*)p->ptr);
		break;
	case SOAP_TYPE__fsres__CFindStationResponse:
		if (p->size < 0)
			SOAP_DELETE((_fsres__CFindStationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fsres__CFindStationResponse*)p->ptr);
		break;
	case SOAP_TYPE_fsres__CFindStationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct fsres__CFindStationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct fsres__CFindStationResponse*)p->ptr);
		break;
	case SOAP_TYPE_CommandStationRequest:
		if (p->size < 0)
			SOAP_DELETE((struct CommandStationRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct CommandStationRequest*)p->ptr);
		break;
	case SOAP_TYPE_csreq__CommandStationRequest:
		if (p->size < 0)
			SOAP_DELETE((struct csreq__CommandStationRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct csreq__CommandStationRequest*)p->ptr);
		break;
	case SOAP_TYPE_CommandStationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct CommandStationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct CommandStationResponse*)p->ptr);
		break;
	case SOAP_TYPE_csres__CommandStationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct csres__CommandStationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct csres__CommandStationResponse*)p->ptr);
		break;
	case SOAP_TYPE_hangpacs__WriteRequest:
		if (p->size < 0)
			SOAP_DELETE((struct hangpacs__WriteRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct hangpacs__WriteRequest*)p->ptr);
		break;
	case SOAP_TYPE_hangpacs__ReadRequest:
		if (p->size < 0)
			SOAP_DELETE((struct hangpacs__ReadRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct hangpacs__ReadRequest*)p->ptr);
		break;
	case SOAP_TYPE_hangpacs__RefreshRequest:
		if (p->size < 0)
			SOAP_DELETE((struct hangpacs__RefreshRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct hangpacs__RefreshRequest*)p->ptr);
		break;
	case SOAP_TYPE_hangpacs__FindReceiver:
		if (p->size < 0)
			SOAP_DELETE((struct hangpacs__FindReceiver*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct hangpacs__FindReceiver*)p->ptr);
		break;
	case SOAP_TYPE_hangpacs__WriteLog:
		if (p->size < 0)
			SOAP_DELETE((struct hangpacs__WriteLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct hangpacs__WriteLog*)p->ptr);
		break;
	case SOAP_TYPE_hangpacs__WriteLogAsync:
		if (p->size < 0)
			SOAP_DELETE((struct hangpacs__WriteLogAsync*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct hangpacs__WriteLogAsync*)p->ptr);
		break;
	case SOAP_TYPE_hangpacs__ReadLog:
		if (p->size < 0)
			SOAP_DELETE((struct hangpacs__ReadLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct hangpacs__ReadLog*)p->ptr);
		break;
	case SOAP_TYPE_hangpacs__FindStation:
		if (p->size < 0)
			SOAP_DELETE((struct hangpacs__FindStation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct hangpacs__FindStation*)p->ptr);
		break;
	case SOAP_TYPE_hangpacs__CommandStation:
		if (p->size < 0)
			SOAP_DELETE((struct hangpacs__CommandStation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct hangpacs__CommandStation*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE__wreq__WriteRequest:
		if (p->size < 0)
			SOAP_DELETE((struct WriteRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct WriteRequest*)p->ptr);
		break;
	case SOAP_TYPE__wres__WriteResponse:
		if (p->size < 0)
			SOAP_DELETE((struct WriteResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct WriteResponse*)p->ptr);
		break;
	case SOAP_TYPE__rreq__ReadRequest:
		if (p->size < 0)
			SOAP_DELETE((struct ReadRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReadRequest*)p->ptr);
		break;
	case SOAP_TYPE__rres__ReadResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ReadResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReadResponse*)p->ptr);
		break;
	case SOAP_TYPE__rreq_RefresRequest:
		if (p->size < 0)
			SOAP_DELETE((struct RefresRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct RefresRequest*)p->ptr);
		break;
	case SOAP_TYPE__rres_RefreshResponse:
		if (p->size < 0)
			SOAP_DELETE((struct RefreshResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct RefreshResponse*)p->ptr);
		break;
	case SOAP_TYPE__frreq_FindReceiverRequest:
		if (p->size < 0)
			SOAP_DELETE((struct FindReceiverRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct FindReceiverRequest*)p->ptr);
		break;
	case SOAP_TYPE__frres_FindReceiverResponse:
		if (p->size < 0)
			SOAP_DELETE((struct FindReceiverResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct FindReceiverResponse*)p->ptr);
		break;
	case SOAP_TYPE__wlreq_WriteLogRequest:
		if (p->size < 0)
			SOAP_DELETE((struct WriteLogRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct WriteLogRequest*)p->ptr);
		break;
	case SOAP_TYPE__wlres_WriteLogResponse:
		if (p->size < 0)
			SOAP_DELETE((struct WriteLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct WriteLogResponse*)p->ptr);
		break;
	case SOAP_TYPE__rlreq_ReadLogRequest:
		if (p->size < 0)
			SOAP_DELETE((struct ReadLogRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReadLogRequest*)p->ptr);
		break;
	case SOAP_TYPE__rlres_ReadLogResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ReadLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReadLogResponse*)p->ptr);
		break;
	case SOAP_TYPE__fsreq_FindStationRequest:
		if (p->size < 0)
			SOAP_DELETE((struct FindStationRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct FindStationRequest*)p->ptr);
		break;
	case SOAP_TYPE__fsres_FindStationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct FindStationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct FindStationResponse*)p->ptr);
		break;
	case SOAP_TYPE__csreq_CommandStationRequest:
		if (p->size < 0)
			SOAP_DELETE((struct CommandStationRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct CommandStationRequest*)p->ptr);
		break;
	case SOAP_TYPE__csres_CommandStationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct CommandStationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct CommandStationResponse*)p->ptr);
		break;
	case SOAP_TYPE_std__listTemplateOf_fsres_FindStationResponse:
		if (p->size < 0)
			SOAP_DELETE((std::list<struct FindStationResponse >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::list<struct FindStationResponse >*)p->ptr);
		break;
	case SOAP_TYPE_std__listTemplateOf_rlres_ReadLogResponse:
		if (p->size < 0)
			SOAP_DELETE((std::list<struct ReadLogResponse >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::list<struct ReadLogResponse >*)p->ptr);
		break;
	case SOAP_TYPE_std__listTemplateOfstd__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::list<std::wstring >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::list<std::wstring >*)p->ptr);
		break;
	case SOAP_TYPE_std__listTemplateOf_rres__ReadResponse:
		if (p->size < 0)
			SOAP_DELETE((std::list<struct ReadResponse >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::list<struct ReadResponse >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__listTemplateOf_fsres_FindStationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		((std::list<struct FindStationResponse >*)p)->insert(((std::list<struct FindStationResponse >*)p)->end(), *(struct FindStationResponse *)q);
		break;
	case SOAP_TYPE_std__listTemplateOf_rlres_ReadLogResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		((std::list<struct ReadLogResponse >*)p)->insert(((std::list<struct ReadLogResponse >*)p)->end(), *(struct ReadLogResponse *)q);
		break;
	case SOAP_TYPE_std__listTemplateOfstd__wstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		((std::list<std::wstring >*)p)->insert(((std::list<std::wstring >*)p)->end(), *(std::wstring *)q);
		break;
	case SOAP_TYPE_std__listTemplateOf_rres__ReadResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		((std::list<struct ReadResponse >*)p)->insert(((std::list<struct ReadResponse >*)p)->end(), *(struct ReadResponse *)q);
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_CommandStation(struct soap *soap, enum CommandStation *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_CommandStation
	*a = SOAP_DEFAULT_CommandStation;
#else
	*a = (enum CommandStation)0;
#endif
}

static const struct soap_code_map soap_codes_CommandStation[] =
{	{ (long)hangpacs__Stop, "hangpacs:Stop" },
	{ (long)hangpacs__Start, "hangpacs:Start" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_CommandStation2s(struct soap *soap, enum CommandStation n)
{	const char *s = soap_code_str(soap_codes_CommandStation, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CommandStation(struct soap *soap, const char *tag, int id, const enum CommandStation *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CommandStation), type) || soap_send(soap, soap_CommandStation2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2CommandStation(struct soap *soap, const char *s, enum CommandStation *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_CommandStation, t);
	if (map)
		*a = (enum CommandStation)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum CommandStation)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum CommandStation * SOAP_FMAC4 soap_in_CommandStation(struct soap *soap, const char *tag, enum CommandStation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum CommandStation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_CommandStation, sizeof(enum CommandStation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2CommandStation(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum CommandStation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CommandStation, 0, sizeof(enum CommandStation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_CommandStation(struct soap *soap, const enum CommandStation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_CommandStation);
	if (soap_out_CommandStation(soap, tag?tag:"CommandStation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum CommandStation * SOAP_FMAC4 soap_get_CommandStation(struct soap *soap, enum CommandStation *p, const char *tag, const char *type)
{
	if ((p = soap_in_CommandStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Processing(struct soap *soap, enum Processing *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_Processing
	*a = SOAP_DEFAULT_Processing;
#else
	*a = (enum Processing)0;
#endif
}

static const struct soap_code_map soap_codes_Processing[] =
{	{ (long)hangpacs__Begin, "hangpacs:Begin" },
	{ (long)hangpacs__Processing, "hangpacs:Processing" },
	{ (long)hangpacs__end, "hangpacs:end" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_Processing2s(struct soap *soap, enum Processing n)
{	const char *s = soap_code_str(soap_codes_Processing, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Processing(struct soap *soap, const char *tag, int id, const enum Processing *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Processing), type) || soap_send(soap, soap_Processing2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2Processing(struct soap *soap, const char *s, enum Processing *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_Processing, t);
	if (map)
		*a = (enum Processing)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum Processing)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum Processing * SOAP_FMAC4 soap_in_Processing(struct soap *soap, const char *tag, enum Processing *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum Processing *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Processing, sizeof(enum Processing), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2Processing(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum Processing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Processing, 0, sizeof(enum Processing), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Processing(struct soap *soap, const enum Processing *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Processing);
	if (soap_out_Processing(soap, tag?tag:"Processing", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum Processing * SOAP_FMAC4 soap_get_Processing(struct soap *soap, enum Processing *p, const char *tag, const char *type)
{
	if ((p = soap_in_Processing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _fsres__CFindStationResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__listTemplateOf_fsres_FindStationResponse(soap, &this->_fsres__CFindStationResponse::m_listResponse);
}

void _fsres__CFindStationResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__listTemplateOf_fsres_FindStationResponse(soap, &this->_fsres__CFindStationResponse::m_listResponse);
#endif
}

int _fsres__CFindStationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fsres__CFindStationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fsres__CFindStationResponse(struct soap *soap, const char *tag, int id, const _fsres__CFindStationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fsres__CFindStationResponse), type))
		return soap->error;
	if (soap_out_std__listTemplateOf_fsres_FindStationResponse(soap, "m-listResponse", -1, &(a->_fsres__CFindStationResponse::m_listResponse), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fsres__CFindStationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fsres__CFindStationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _fsres__CFindStationResponse * SOAP_FMAC4 soap_in__fsres__CFindStationResponse(struct soap *soap, const char *tag, _fsres__CFindStationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fsres__CFindStationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fsres__CFindStationResponse, sizeof(_fsres__CFindStationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fsres__CFindStationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fsres__CFindStationResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__listTemplateOf_fsres_FindStationResponse(soap, "m-listResponse", &(a->_fsres__CFindStationResponse::m_listResponse), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fsres__CFindStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fsres__CFindStationResponse, 0, sizeof(_fsres__CFindStationResponse), 0, soap_copy__fsres__CFindStationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fsres__CFindStationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fsres__CFindStationResponse);
	if (this->soap_out(soap, tag?tag:"fsres:CFindStationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fsres__CFindStationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fsres__CFindStationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _fsres__CFindStationResponse * SOAP_FMAC4 soap_get__fsres__CFindStationResponse(struct soap *soap, _fsres__CFindStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__fsres__CFindStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fsres__CFindStationResponse * SOAP_FMAC2 soap_instantiate__fsres__CFindStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fsres__CFindStationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fsres__CFindStationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fsres__CFindStationResponse);
		if (size)
			*size = sizeof(_fsres__CFindStationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fsres__CFindStationResponse, n);
		if (size)
			*size = n * sizeof(_fsres__CFindStationResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fsres__CFindStationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fsres__CFindStationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fsres__CFindStationResponse %p -> %p\n", q, p));
	*(_fsres__CFindStationResponse*)p = *(_fsres__CFindStationResponse*)q;
}

void _rlres__CReadLogResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__listTemplateOf_rlres_ReadLogResponse(soap, &this->_rlres__CReadLogResponse::m_listResponse);
}

void _rlres__CReadLogResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__listTemplateOf_rlres_ReadLogResponse(soap, &this->_rlres__CReadLogResponse::m_listResponse);
#endif
}

int _rlres__CReadLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__rlres__CReadLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__rlres__CReadLogResponse(struct soap *soap, const char *tag, int id, const _rlres__CReadLogResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__rlres__CReadLogResponse), type))
		return soap->error;
	if (soap_out_std__listTemplateOf_rlres_ReadLogResponse(soap, "m-listResponse", -1, &(a->_rlres__CReadLogResponse::m_listResponse), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_rlres__CReadLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__rlres__CReadLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 _rlres__CReadLogResponse * SOAP_FMAC4 soap_in__rlres__CReadLogResponse(struct soap *soap, const char *tag, _rlres__CReadLogResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_rlres__CReadLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__rlres__CReadLogResponse, sizeof(_rlres__CReadLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__rlres__CReadLogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_rlres__CReadLogResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__listTemplateOf_rlres_ReadLogResponse(soap, "m-listResponse", &(a->_rlres__CReadLogResponse::m_listResponse), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_rlres__CReadLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__rlres__CReadLogResponse, 0, sizeof(_rlres__CReadLogResponse), 0, soap_copy__rlres__CReadLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _rlres__CReadLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__rlres__CReadLogResponse);
	if (this->soap_out(soap, tag?tag:"rlres:CReadLogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_rlres__CReadLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__rlres__CReadLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 _rlres__CReadLogResponse * SOAP_FMAC4 soap_get__rlres__CReadLogResponse(struct soap *soap, _rlres__CReadLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__rlres__CReadLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _rlres__CReadLogResponse * SOAP_FMAC2 soap_instantiate__rlres__CReadLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__rlres__CReadLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__rlres__CReadLogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_rlres__CReadLogResponse);
		if (size)
			*size = sizeof(_rlres__CReadLogResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_rlres__CReadLogResponse, n);
		if (size)
			*size = n * sizeof(_rlres__CReadLogResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_rlres__CReadLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__rlres__CReadLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _rlres__CReadLogResponse %p -> %p\n", q, p));
	*(_rlres__CReadLogResponse*)p = *(_rlres__CReadLogResponse*)q;
}

void _rres__CReadResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__listTemplateOf_rres__ReadResponse(soap, &this->_rres__CReadResponse::m_listResponse);
}

void _rres__CReadResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__listTemplateOf_rres__ReadResponse(soap, &this->_rres__CReadResponse::m_listResponse);
#endif
}

int _rres__CReadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__rres__CReadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__rres__CReadResponse(struct soap *soap, const char *tag, int id, const _rres__CReadResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__rres__CReadResponse), type))
		return soap->error;
	if (soap_out_std__listTemplateOf_rres__ReadResponse(soap, "m-listResponse", -1, &(a->_rres__CReadResponse::m_listResponse), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_rres__CReadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__rres__CReadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _rres__CReadResponse * SOAP_FMAC4 soap_in__rres__CReadResponse(struct soap *soap, const char *tag, _rres__CReadResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_rres__CReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__rres__CReadResponse, sizeof(_rres__CReadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__rres__CReadResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_rres__CReadResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__listTemplateOf_rres__ReadResponse(soap, "m-listResponse", &(a->_rres__CReadResponse::m_listResponse), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_rres__CReadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__rres__CReadResponse, 0, sizeof(_rres__CReadResponse), 0, soap_copy__rres__CReadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _rres__CReadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__rres__CReadResponse);
	if (this->soap_out(soap, tag?tag:"rres:CReadResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_rres__CReadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__rres__CReadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _rres__CReadResponse * SOAP_FMAC4 soap_get__rres__CReadResponse(struct soap *soap, _rres__CReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__rres__CReadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _rres__CReadResponse * SOAP_FMAC2 soap_instantiate__rres__CReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__rres__CReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__rres__CReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_rres__CReadResponse);
		if (size)
			*size = sizeof(_rres__CReadResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_rres__CReadResponse, n);
		if (size)
			*size = n * sizeof(_rres__CReadResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_rres__CReadResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__rres__CReadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _rres__CReadResponse %p -> %p\n", q, p));
	*(_rres__CReadResponse*)p = *(_rres__CReadResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__wstring);
	if (soap_out_std__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::wstring);
		if (size)
			*size = sizeof(std::wstring);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::wstring, n);
		if (size)
			*size = n * sizeof(std::wstring);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::wstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
	*(std::wstring*)p = *(std::wstring*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_hangpacs__CommandStation(struct soap *soap, struct hangpacs__CommandStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_csreq__CommandStationRequest(soap, &a->stReqMsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_hangpacs__CommandStation(struct soap *soap, const struct hangpacs__CommandStation *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_csreq__CommandStationRequest(soap, &a->stReqMsg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_hangpacs__CommandStation(struct soap *soap, const char *tag, int id, const struct hangpacs__CommandStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hangpacs__CommandStation), type))
		return soap->error;
	if (soap_out_csreq__CommandStationRequest(soap, "stReqMsg", -1, &a->stReqMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct hangpacs__CommandStation * SOAP_FMAC4 soap_in_hangpacs__CommandStation(struct soap *soap, const char *tag, struct hangpacs__CommandStation *a, const char *type)
{
	size_t soap_flag_stReqMsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hangpacs__CommandStation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_hangpacs__CommandStation, sizeof(struct hangpacs__CommandStation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_hangpacs__CommandStation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stReqMsg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_csreq__CommandStationRequest(soap, "stReqMsg", &a->stReqMsg, "csreq:CommandStationRequest"))
				{	soap_flag_stReqMsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct hangpacs__CommandStation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hangpacs__CommandStation, 0, sizeof(struct hangpacs__CommandStation), 0, soap_copy_hangpacs__CommandStation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stReqMsg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_hangpacs__CommandStation(struct soap *soap, const struct hangpacs__CommandStation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hangpacs__CommandStation);
	if (soap_out_hangpacs__CommandStation(soap, tag?tag:"hangpacs:CommandStation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct hangpacs__CommandStation * SOAP_FMAC4 soap_get_hangpacs__CommandStation(struct soap *soap, struct hangpacs__CommandStation *p, const char *tag, const char *type)
{
	if ((p = soap_in_hangpacs__CommandStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct hangpacs__CommandStation * SOAP_FMAC2 soap_instantiate_hangpacs__CommandStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_hangpacs__CommandStation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_hangpacs__CommandStation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct hangpacs__CommandStation);
		if (size)
			*size = sizeof(struct hangpacs__CommandStation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct hangpacs__CommandStation, n);
		if (size)
			*size = n * sizeof(struct hangpacs__CommandStation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct hangpacs__CommandStation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_hangpacs__CommandStation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct hangpacs__CommandStation %p -> %p\n", q, p));
	*(struct hangpacs__CommandStation*)p = *(struct hangpacs__CommandStation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_hangpacs__FindStation(struct soap *soap, struct hangpacs__FindStation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_fsreq__FindStationRequest(soap, &a->stReqMsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_hangpacs__FindStation(struct soap *soap, const struct hangpacs__FindStation *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_fsreq__FindStationRequest(soap, &a->stReqMsg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_hangpacs__FindStation(struct soap *soap, const char *tag, int id, const struct hangpacs__FindStation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hangpacs__FindStation), type))
		return soap->error;
	if (soap_out_fsreq__FindStationRequest(soap, "stReqMsg", -1, &a->stReqMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct hangpacs__FindStation * SOAP_FMAC4 soap_in_hangpacs__FindStation(struct soap *soap, const char *tag, struct hangpacs__FindStation *a, const char *type)
{
	size_t soap_flag_stReqMsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hangpacs__FindStation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hangpacs__FindStation, sizeof(struct hangpacs__FindStation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hangpacs__FindStation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stReqMsg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fsreq__FindStationRequest(soap, "stReqMsg", &a->stReqMsg, "fsreq:FindStationRequest"))
				{	soap_flag_stReqMsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct hangpacs__FindStation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hangpacs__FindStation, 0, sizeof(struct hangpacs__FindStation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stReqMsg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_hangpacs__FindStation(struct soap *soap, const struct hangpacs__FindStation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hangpacs__FindStation);
	if (soap_out_hangpacs__FindStation(soap, tag?tag:"hangpacs:FindStation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct hangpacs__FindStation * SOAP_FMAC4 soap_get_hangpacs__FindStation(struct soap *soap, struct hangpacs__FindStation *p, const char *tag, const char *type)
{
	if ((p = soap_in_hangpacs__FindStation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct hangpacs__FindStation * SOAP_FMAC2 soap_instantiate_hangpacs__FindStation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_hangpacs__FindStation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_hangpacs__FindStation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct hangpacs__FindStation);
		if (size)
			*size = sizeof(struct hangpacs__FindStation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct hangpacs__FindStation, n);
		if (size)
			*size = n * sizeof(struct hangpacs__FindStation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct hangpacs__FindStation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_hangpacs__FindStation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct hangpacs__FindStation %p -> %p\n", q, p));
	*(struct hangpacs__FindStation*)p = *(struct hangpacs__FindStation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_hangpacs__ReadLog(struct soap *soap, struct hangpacs__ReadLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_rlreq__ReadLogRequest(soap, &a->stReqMsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_hangpacs__ReadLog(struct soap *soap, const struct hangpacs__ReadLog *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_rlreq__ReadLogRequest(soap, &a->stReqMsg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_hangpacs__ReadLog(struct soap *soap, const char *tag, int id, const struct hangpacs__ReadLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hangpacs__ReadLog), type))
		return soap->error;
	if (soap_out_rlreq__ReadLogRequest(soap, "stReqMsg", -1, &a->stReqMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct hangpacs__ReadLog * SOAP_FMAC4 soap_in_hangpacs__ReadLog(struct soap *soap, const char *tag, struct hangpacs__ReadLog *a, const char *type)
{
	size_t soap_flag_stReqMsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hangpacs__ReadLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_hangpacs__ReadLog, sizeof(struct hangpacs__ReadLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_hangpacs__ReadLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stReqMsg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_rlreq__ReadLogRequest(soap, "stReqMsg", &a->stReqMsg, "rlreq:ReadLogRequest"))
				{	soap_flag_stReqMsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct hangpacs__ReadLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hangpacs__ReadLog, 0, sizeof(struct hangpacs__ReadLog), 0, soap_copy_hangpacs__ReadLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stReqMsg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_hangpacs__ReadLog(struct soap *soap, const struct hangpacs__ReadLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hangpacs__ReadLog);
	if (soap_out_hangpacs__ReadLog(soap, tag?tag:"hangpacs:ReadLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct hangpacs__ReadLog * SOAP_FMAC4 soap_get_hangpacs__ReadLog(struct soap *soap, struct hangpacs__ReadLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_hangpacs__ReadLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct hangpacs__ReadLog * SOAP_FMAC2 soap_instantiate_hangpacs__ReadLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_hangpacs__ReadLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_hangpacs__ReadLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct hangpacs__ReadLog);
		if (size)
			*size = sizeof(struct hangpacs__ReadLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct hangpacs__ReadLog, n);
		if (size)
			*size = n * sizeof(struct hangpacs__ReadLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct hangpacs__ReadLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_hangpacs__ReadLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct hangpacs__ReadLog %p -> %p\n", q, p));
	*(struct hangpacs__ReadLog*)p = *(struct hangpacs__ReadLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_hangpacs__WriteLogAsync(struct soap *soap, struct hangpacs__WriteLogAsync *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wlreq__WriteLogRequest(soap, &a->stReqMsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_hangpacs__WriteLogAsync(struct soap *soap, const struct hangpacs__WriteLogAsync *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wlreq__WriteLogRequest(soap, &a->stReqMsg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_hangpacs__WriteLogAsync(struct soap *soap, const char *tag, int id, const struct hangpacs__WriteLogAsync *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hangpacs__WriteLogAsync), type))
		return soap->error;
	if (soap_out_wlreq__WriteLogRequest(soap, "stReqMsg", -1, &a->stReqMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct hangpacs__WriteLogAsync * SOAP_FMAC4 soap_in_hangpacs__WriteLogAsync(struct soap *soap, const char *tag, struct hangpacs__WriteLogAsync *a, const char *type)
{
	size_t soap_flag_stReqMsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hangpacs__WriteLogAsync *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_hangpacs__WriteLogAsync, sizeof(struct hangpacs__WriteLogAsync), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_hangpacs__WriteLogAsync(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stReqMsg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wlreq__WriteLogRequest(soap, "stReqMsg", &a->stReqMsg, "wlreq:WriteLogRequest"))
				{	soap_flag_stReqMsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct hangpacs__WriteLogAsync *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hangpacs__WriteLogAsync, 0, sizeof(struct hangpacs__WriteLogAsync), 0, soap_copy_hangpacs__WriteLogAsync);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stReqMsg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_hangpacs__WriteLogAsync(struct soap *soap, const struct hangpacs__WriteLogAsync *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hangpacs__WriteLogAsync);
	if (soap_out_hangpacs__WriteLogAsync(soap, tag?tag:"hangpacs:WriteLogAsync", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct hangpacs__WriteLogAsync * SOAP_FMAC4 soap_get_hangpacs__WriteLogAsync(struct soap *soap, struct hangpacs__WriteLogAsync *p, const char *tag, const char *type)
{
	if ((p = soap_in_hangpacs__WriteLogAsync(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct hangpacs__WriteLogAsync * SOAP_FMAC2 soap_instantiate_hangpacs__WriteLogAsync(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_hangpacs__WriteLogAsync(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_hangpacs__WriteLogAsync, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct hangpacs__WriteLogAsync);
		if (size)
			*size = sizeof(struct hangpacs__WriteLogAsync);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct hangpacs__WriteLogAsync, n);
		if (size)
			*size = n * sizeof(struct hangpacs__WriteLogAsync);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct hangpacs__WriteLogAsync*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_hangpacs__WriteLogAsync(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct hangpacs__WriteLogAsync %p -> %p\n", q, p));
	*(struct hangpacs__WriteLogAsync*)p = *(struct hangpacs__WriteLogAsync*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_hangpacs__WriteLog(struct soap *soap, struct hangpacs__WriteLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wlreq__WriteLogRequest(soap, &a->stReqMsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_hangpacs__WriteLog(struct soap *soap, const struct hangpacs__WriteLog *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wlreq__WriteLogRequest(soap, &a->stReqMsg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_hangpacs__WriteLog(struct soap *soap, const char *tag, int id, const struct hangpacs__WriteLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hangpacs__WriteLog), type))
		return soap->error;
	if (soap_out_wlreq__WriteLogRequest(soap, "stReqMsg", -1, &a->stReqMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct hangpacs__WriteLog * SOAP_FMAC4 soap_in_hangpacs__WriteLog(struct soap *soap, const char *tag, struct hangpacs__WriteLog *a, const char *type)
{
	size_t soap_flag_stReqMsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hangpacs__WriteLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_hangpacs__WriteLog, sizeof(struct hangpacs__WriteLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_hangpacs__WriteLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stReqMsg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wlreq__WriteLogRequest(soap, "stReqMsg", &a->stReqMsg, "wlreq:WriteLogRequest"))
				{	soap_flag_stReqMsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct hangpacs__WriteLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hangpacs__WriteLog, 0, sizeof(struct hangpacs__WriteLog), 0, soap_copy_hangpacs__WriteLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stReqMsg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_hangpacs__WriteLog(struct soap *soap, const struct hangpacs__WriteLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hangpacs__WriteLog);
	if (soap_out_hangpacs__WriteLog(soap, tag?tag:"hangpacs:WriteLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct hangpacs__WriteLog * SOAP_FMAC4 soap_get_hangpacs__WriteLog(struct soap *soap, struct hangpacs__WriteLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_hangpacs__WriteLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct hangpacs__WriteLog * SOAP_FMAC2 soap_instantiate_hangpacs__WriteLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_hangpacs__WriteLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_hangpacs__WriteLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct hangpacs__WriteLog);
		if (size)
			*size = sizeof(struct hangpacs__WriteLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct hangpacs__WriteLog, n);
		if (size)
			*size = n * sizeof(struct hangpacs__WriteLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct hangpacs__WriteLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_hangpacs__WriteLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct hangpacs__WriteLog %p -> %p\n", q, p));
	*(struct hangpacs__WriteLog*)p = *(struct hangpacs__WriteLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_hangpacs__FindReceiver(struct soap *soap, struct hangpacs__FindReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_frreq__FindReceiverRequest(soap, &a->stReqMsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_hangpacs__FindReceiver(struct soap *soap, const struct hangpacs__FindReceiver *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_frreq__FindReceiverRequest(soap, &a->stReqMsg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_hangpacs__FindReceiver(struct soap *soap, const char *tag, int id, const struct hangpacs__FindReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hangpacs__FindReceiver), type))
		return soap->error;
	if (soap_out_frreq__FindReceiverRequest(soap, "stReqMsg", -1, &a->stReqMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct hangpacs__FindReceiver * SOAP_FMAC4 soap_in_hangpacs__FindReceiver(struct soap *soap, const char *tag, struct hangpacs__FindReceiver *a, const char *type)
{
	size_t soap_flag_stReqMsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hangpacs__FindReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hangpacs__FindReceiver, sizeof(struct hangpacs__FindReceiver), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hangpacs__FindReceiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stReqMsg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_frreq__FindReceiverRequest(soap, "stReqMsg", &a->stReqMsg, "frreq:FindReceiverRequest"))
				{	soap_flag_stReqMsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct hangpacs__FindReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hangpacs__FindReceiver, 0, sizeof(struct hangpacs__FindReceiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stReqMsg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_hangpacs__FindReceiver(struct soap *soap, const struct hangpacs__FindReceiver *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hangpacs__FindReceiver);
	if (soap_out_hangpacs__FindReceiver(soap, tag?tag:"hangpacs:FindReceiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct hangpacs__FindReceiver * SOAP_FMAC4 soap_get_hangpacs__FindReceiver(struct soap *soap, struct hangpacs__FindReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in_hangpacs__FindReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct hangpacs__FindReceiver * SOAP_FMAC2 soap_instantiate_hangpacs__FindReceiver(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_hangpacs__FindReceiver(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_hangpacs__FindReceiver, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct hangpacs__FindReceiver);
		if (size)
			*size = sizeof(struct hangpacs__FindReceiver);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct hangpacs__FindReceiver, n);
		if (size)
			*size = n * sizeof(struct hangpacs__FindReceiver);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct hangpacs__FindReceiver*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_hangpacs__FindReceiver(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct hangpacs__FindReceiver %p -> %p\n", q, p));
	*(struct hangpacs__FindReceiver*)p = *(struct hangpacs__FindReceiver*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_hangpacs__RefreshRequest(struct soap *soap, struct hangpacs__RefreshRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_rreq__RefreshRequest(soap, &a->stReqMsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_hangpacs__RefreshRequest(struct soap *soap, const struct hangpacs__RefreshRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_rreq__RefreshRequest(soap, &a->stReqMsg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_hangpacs__RefreshRequest(struct soap *soap, const char *tag, int id, const struct hangpacs__RefreshRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hangpacs__RefreshRequest), type))
		return soap->error;
	if (soap_out_rreq__RefreshRequest(soap, "stReqMsg", -1, &a->stReqMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct hangpacs__RefreshRequest * SOAP_FMAC4 soap_in_hangpacs__RefreshRequest(struct soap *soap, const char *tag, struct hangpacs__RefreshRequest *a, const char *type)
{
	size_t soap_flag_stReqMsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hangpacs__RefreshRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hangpacs__RefreshRequest, sizeof(struct hangpacs__RefreshRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hangpacs__RefreshRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stReqMsg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_rreq__RefreshRequest(soap, "stReqMsg", &a->stReqMsg, "rreq:RefreshRequest"))
				{	soap_flag_stReqMsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct hangpacs__RefreshRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hangpacs__RefreshRequest, 0, sizeof(struct hangpacs__RefreshRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stReqMsg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_hangpacs__RefreshRequest(struct soap *soap, const struct hangpacs__RefreshRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hangpacs__RefreshRequest);
	if (soap_out_hangpacs__RefreshRequest(soap, tag?tag:"hangpacs:RefreshRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct hangpacs__RefreshRequest * SOAP_FMAC4 soap_get_hangpacs__RefreshRequest(struct soap *soap, struct hangpacs__RefreshRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_hangpacs__RefreshRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct hangpacs__RefreshRequest * SOAP_FMAC2 soap_instantiate_hangpacs__RefreshRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_hangpacs__RefreshRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_hangpacs__RefreshRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct hangpacs__RefreshRequest);
		if (size)
			*size = sizeof(struct hangpacs__RefreshRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct hangpacs__RefreshRequest, n);
		if (size)
			*size = n * sizeof(struct hangpacs__RefreshRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct hangpacs__RefreshRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_hangpacs__RefreshRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct hangpacs__RefreshRequest %p -> %p\n", q, p));
	*(struct hangpacs__RefreshRequest*)p = *(struct hangpacs__RefreshRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_hangpacs__ReadRequest(struct soap *soap, struct hangpacs__ReadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_rreq__ReadRequest(soap, &a->stReqMsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_hangpacs__ReadRequest(struct soap *soap, const struct hangpacs__ReadRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_rreq__ReadRequest(soap, &a->stReqMsg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_hangpacs__ReadRequest(struct soap *soap, const char *tag, int id, const struct hangpacs__ReadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hangpacs__ReadRequest), type))
		return soap->error;
	if (soap_out_rreq__ReadRequest(soap, "stReqMsg", -1, &a->stReqMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct hangpacs__ReadRequest * SOAP_FMAC4 soap_in_hangpacs__ReadRequest(struct soap *soap, const char *tag, struct hangpacs__ReadRequest *a, const char *type)
{
	size_t soap_flag_stReqMsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hangpacs__ReadRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_hangpacs__ReadRequest, sizeof(struct hangpacs__ReadRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_hangpacs__ReadRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stReqMsg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_rreq__ReadRequest(soap, "stReqMsg", &a->stReqMsg, "rreq:ReadRequest"))
				{	soap_flag_stReqMsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct hangpacs__ReadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hangpacs__ReadRequest, 0, sizeof(struct hangpacs__ReadRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stReqMsg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_hangpacs__ReadRequest(struct soap *soap, const struct hangpacs__ReadRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hangpacs__ReadRequest);
	if (soap_out_hangpacs__ReadRequest(soap, tag?tag:"hangpacs:ReadRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct hangpacs__ReadRequest * SOAP_FMAC4 soap_get_hangpacs__ReadRequest(struct soap *soap, struct hangpacs__ReadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_hangpacs__ReadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct hangpacs__ReadRequest * SOAP_FMAC2 soap_instantiate_hangpacs__ReadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_hangpacs__ReadRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_hangpacs__ReadRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct hangpacs__ReadRequest);
		if (size)
			*size = sizeof(struct hangpacs__ReadRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct hangpacs__ReadRequest, n);
		if (size)
			*size = n * sizeof(struct hangpacs__ReadRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct hangpacs__ReadRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_hangpacs__ReadRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct hangpacs__ReadRequest %p -> %p\n", q, p));
	*(struct hangpacs__ReadRequest*)p = *(struct hangpacs__ReadRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_hangpacs__WriteRequest(struct soap *soap, struct hangpacs__WriteRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wreq__WriteRequest(soap, &a->stReqMsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_hangpacs__WriteRequest(struct soap *soap, const struct hangpacs__WriteRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wreq__WriteRequest(soap, &a->stReqMsg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_hangpacs__WriteRequest(struct soap *soap, const char *tag, int id, const struct hangpacs__WriteRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_hangpacs__WriteRequest), type))
		return soap->error;
	if (soap_out_wreq__WriteRequest(soap, "stReqMsg", -1, &a->stReqMsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct hangpacs__WriteRequest * SOAP_FMAC4 soap_in_hangpacs__WriteRequest(struct soap *soap, const char *tag, struct hangpacs__WriteRequest *a, const char *type)
{
	size_t soap_flag_stReqMsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct hangpacs__WriteRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_hangpacs__WriteRequest, sizeof(struct hangpacs__WriteRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_hangpacs__WriteRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stReqMsg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wreq__WriteRequest(soap, "stReqMsg", &a->stReqMsg, "wreq:WriteRequest"))
				{	soap_flag_stReqMsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct hangpacs__WriteRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_hangpacs__WriteRequest, 0, sizeof(struct hangpacs__WriteRequest), 0, soap_copy_hangpacs__WriteRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stReqMsg > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_hangpacs__WriteRequest(struct soap *soap, const struct hangpacs__WriteRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_hangpacs__WriteRequest);
	if (soap_out_hangpacs__WriteRequest(soap, tag?tag:"hangpacs:WriteRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct hangpacs__WriteRequest * SOAP_FMAC4 soap_get_hangpacs__WriteRequest(struct soap *soap, struct hangpacs__WriteRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_hangpacs__WriteRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct hangpacs__WriteRequest * SOAP_FMAC2 soap_instantiate_hangpacs__WriteRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_hangpacs__WriteRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_hangpacs__WriteRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct hangpacs__WriteRequest);
		if (size)
			*size = sizeof(struct hangpacs__WriteRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct hangpacs__WriteRequest, n);
		if (size)
			*size = n * sizeof(struct hangpacs__WriteRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct hangpacs__WriteRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_hangpacs__WriteRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct hangpacs__WriteRequest %p -> %p\n", q, p));
	*(struct hangpacs__WriteRequest*)p = *(struct hangpacs__WriteRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_csres__CommandStationResponse(struct soap *soap, struct csres__CommandStationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__csres_CommandStationResponse(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_csres__CommandStationResponse(struct soap *soap, const struct csres__CommandStationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__csres_CommandStationResponse(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_csres__CommandStationResponse(struct soap *soap, const char *tag, int id, const struct csres__CommandStationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_csres__CommandStationResponse), type))
		return soap->error;
	if (soap_out__csres_CommandStationResponse(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct csres__CommandStationResponse * SOAP_FMAC4 soap_in_csres__CommandStationResponse(struct soap *soap, const char *tag, struct csres__CommandStationResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct csres__CommandStationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_csres__CommandStationResponse, sizeof(struct csres__CommandStationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_csres__CommandStationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__csres_CommandStationResponse(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct csres__CommandStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_csres__CommandStationResponse, 0, sizeof(struct csres__CommandStationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_csres__CommandStationResponse(struct soap *soap, const struct csres__CommandStationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_csres__CommandStationResponse);
	if (soap_out_csres__CommandStationResponse(soap, tag?tag:"csres:CommandStationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct csres__CommandStationResponse * SOAP_FMAC4 soap_get_csres__CommandStationResponse(struct soap *soap, struct csres__CommandStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_csres__CommandStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct csres__CommandStationResponse * SOAP_FMAC2 soap_instantiate_csres__CommandStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_csres__CommandStationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_csres__CommandStationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct csres__CommandStationResponse);
		if (size)
			*size = sizeof(struct csres__CommandStationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct csres__CommandStationResponse, n);
		if (size)
			*size = n * sizeof(struct csres__CommandStationResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct csres__CommandStationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_csres__CommandStationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct csres__CommandStationResponse %p -> %p\n", q, p));
	*(struct csres__CommandStationResponse*)p = *(struct csres__CommandStationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_CommandStationResponse(struct soap *soap, struct CommandStationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->bDummy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_CommandStationResponse(struct soap *soap, const struct CommandStationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CommandStationResponse(struct soap *soap, const char *tag, int id, const struct CommandStationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CommandStationResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "bDummy", -1, &a->bDummy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct CommandStationResponse * SOAP_FMAC4 soap_in_CommandStationResponse(struct soap *soap, const char *tag, struct CommandStationResponse *a, const char *type)
{
	size_t soap_flag_bDummy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct CommandStationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_CommandStationResponse, sizeof(struct CommandStationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_CommandStationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bDummy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDummy", &a->bDummy, "xsd:boolean"))
				{	soap_flag_bDummy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct CommandStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CommandStationResponse, 0, sizeof(struct CommandStationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bDummy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_CommandStationResponse(struct soap *soap, const struct CommandStationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_CommandStationResponse);
	if (soap_out_CommandStationResponse(soap, tag?tag:"CommandStationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct CommandStationResponse * SOAP_FMAC4 soap_get_CommandStationResponse(struct soap *soap, struct CommandStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_CommandStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct CommandStationResponse * SOAP_FMAC2 soap_instantiate_CommandStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CommandStationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CommandStationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct CommandStationResponse);
		if (size)
			*size = sizeof(struct CommandStationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct CommandStationResponse, n);
		if (size)
			*size = n * sizeof(struct CommandStationResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct CommandStationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CommandStationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct CommandStationResponse %p -> %p\n", q, p));
	*(struct CommandStationResponse*)p = *(struct CommandStationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_csreq__CommandStationRequest(struct soap *soap, struct csreq__CommandStationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__csreq_CommandStationRequest(soap, &a->retrun_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_csreq__CommandStationRequest(struct soap *soap, const struct csreq__CommandStationRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__csreq_CommandStationRequest(soap, &a->retrun_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_csreq__CommandStationRequest(struct soap *soap, const char *tag, int id, const struct csreq__CommandStationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_csreq__CommandStationRequest), type))
		return soap->error;
	if (soap_out__csreq_CommandStationRequest(soap, "retrun", -1, &a->retrun_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct csreq__CommandStationRequest * SOAP_FMAC4 soap_in_csreq__CommandStationRequest(struct soap *soap, const char *tag, struct csreq__CommandStationRequest *a, const char *type)
{
	size_t soap_flag_retrun_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct csreq__CommandStationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_csreq__CommandStationRequest, sizeof(struct csreq__CommandStationRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_csreq__CommandStationRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_retrun_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__csreq_CommandStationRequest(soap, "retrun", &a->retrun_, ""))
				{	soap_flag_retrun_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct csreq__CommandStationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_csreq__CommandStationRequest, 0, sizeof(struct csreq__CommandStationRequest), 0, soap_copy_csreq__CommandStationRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retrun_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_csreq__CommandStationRequest(struct soap *soap, const struct csreq__CommandStationRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_csreq__CommandStationRequest);
	if (soap_out_csreq__CommandStationRequest(soap, tag?tag:"csreq:CommandStationRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct csreq__CommandStationRequest * SOAP_FMAC4 soap_get_csreq__CommandStationRequest(struct soap *soap, struct csreq__CommandStationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_csreq__CommandStationRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct csreq__CommandStationRequest * SOAP_FMAC2 soap_instantiate_csreq__CommandStationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_csreq__CommandStationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_csreq__CommandStationRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct csreq__CommandStationRequest);
		if (size)
			*size = sizeof(struct csreq__CommandStationRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct csreq__CommandStationRequest, n);
		if (size)
			*size = n * sizeof(struct csreq__CommandStationRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct csreq__CommandStationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_csreq__CommandStationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct csreq__CommandStationRequest %p -> %p\n", q, p));
	*(struct csreq__CommandStationRequest*)p = *(struct csreq__CommandStationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_CommandStationRequest(struct soap *soap, struct CommandStationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__hangpacs__CommandStation(soap, &a->eCommand);
	soap_default_std__wstring(soap, &a->strStationName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_CommandStationRequest(struct soap *soap, const struct CommandStationRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__wstring(soap, &a->strStationName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CommandStationRequest(struct soap *soap, const char *tag, int id, const struct CommandStationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CommandStationRequest), type))
		return soap->error;
	if (soap_out__hangpacs__CommandStation(soap, "eCommand", -1, &a->eCommand, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strStationName", -1, &a->strStationName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct CommandStationRequest * SOAP_FMAC4 soap_in_CommandStationRequest(struct soap *soap, const char *tag, struct CommandStationRequest *a, const char *type)
{
	size_t soap_flag_eCommand = 1;
	size_t soap_flag_strStationName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct CommandStationRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CommandStationRequest, sizeof(struct CommandStationRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_CommandStationRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eCommand && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__hangpacs__CommandStation(soap, "eCommand", &a->eCommand, ""))
				{	soap_flag_eCommand--;
					continue;
				}
			if (soap_flag_strStationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strStationName", &a->strStationName, "xsd:string"))
				{	soap_flag_strStationName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct CommandStationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CommandStationRequest, 0, sizeof(struct CommandStationRequest), 0, soap_copy_CommandStationRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eCommand > 0 || soap_flag_strStationName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_CommandStationRequest(struct soap *soap, const struct CommandStationRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_CommandStationRequest);
	if (soap_out_CommandStationRequest(soap, tag?tag:"CommandStationRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct CommandStationRequest * SOAP_FMAC4 soap_get_CommandStationRequest(struct soap *soap, struct CommandStationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_CommandStationRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct CommandStationRequest * SOAP_FMAC2 soap_instantiate_CommandStationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CommandStationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CommandStationRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct CommandStationRequest);
		if (size)
			*size = sizeof(struct CommandStationRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct CommandStationRequest, n);
		if (size)
			*size = n * sizeof(struct CommandStationRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct CommandStationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CommandStationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct CommandStationRequest %p -> %p\n", q, p));
	*(struct CommandStationRequest*)p = *(struct CommandStationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fsres__CFindStationResponse(struct soap *soap, struct fsres__CFindStationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_._fsres__CFindStationResponse::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fsres__CFindStationResponse(struct soap *soap, const struct fsres__CFindStationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fsres__CFindStationResponse(struct soap *soap, const char *tag, int id, const struct fsres__CFindStationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fsres__CFindStationResponse), type))
		return soap->error;
	if (a->return_.soap_out(soap, "return", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fsres__CFindStationResponse * SOAP_FMAC4 soap_in_fsres__CFindStationResponse(struct soap *soap, const char *tag, struct fsres__CFindStationResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fsres__CFindStationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fsres__CFindStationResponse, sizeof(struct fsres__CFindStationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fsres__CFindStationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (a->return_.soap_in(soap, "return", ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fsres__CFindStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fsres__CFindStationResponse, 0, sizeof(struct fsres__CFindStationResponse), 0, soap_copy_fsres__CFindStationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fsres__CFindStationResponse(struct soap *soap, const struct fsres__CFindStationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fsres__CFindStationResponse);
	if (soap_out_fsres__CFindStationResponse(soap, tag?tag:"fsres:CFindStationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct fsres__CFindStationResponse * SOAP_FMAC4 soap_get_fsres__CFindStationResponse(struct soap *soap, struct fsres__CFindStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fsres__CFindStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct fsres__CFindStationResponse * SOAP_FMAC2 soap_instantiate_fsres__CFindStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fsres__CFindStationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fsres__CFindStationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct fsres__CFindStationResponse);
		if (size)
			*size = sizeof(struct fsres__CFindStationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct fsres__CFindStationResponse, n);
		if (size)
			*size = n * sizeof(struct fsres__CFindStationResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct fsres__CFindStationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fsres__CFindStationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fsres__CFindStationResponse %p -> %p\n", q, p));
	*(struct fsres__CFindStationResponse*)p = *(struct fsres__CFindStationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_FindStationResponse(struct soap *soap, struct FindStationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &a->strIPAddress);
	soap_default_std__wstring(soap, &a->strStationName);
	soap_default_std__wstring(soap, &a->strStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_FindStationResponse(struct soap *soap, const struct FindStationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__wstring(soap, &a->strIPAddress);
	soap_serialize_std__wstring(soap, &a->strStationName);
	soap_serialize_std__wstring(soap, &a->strStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_FindStationResponse(struct soap *soap, const char *tag, int id, const struct FindStationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FindStationResponse), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "strIPAddress", -1, &a->strIPAddress, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strStationName", -1, &a->strStationName, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strStatus", -1, &a->strStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct FindStationResponse * SOAP_FMAC4 soap_in_FindStationResponse(struct soap *soap, const char *tag, struct FindStationResponse *a, const char *type)
{
	size_t soap_flag_strIPAddress = 1;
	size_t soap_flag_strStationName = 1;
	size_t soap_flag_strStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct FindStationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FindStationResponse, sizeof(struct FindStationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_FindStationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strIPAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strIPAddress", &a->strIPAddress, "xsd:string"))
				{	soap_flag_strIPAddress--;
					continue;
				}
			if (soap_flag_strStationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strStationName", &a->strStationName, "xsd:string"))
				{	soap_flag_strStationName--;
					continue;
				}
			if (soap_flag_strStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strStatus", &a->strStatus, "xsd:string"))
				{	soap_flag_strStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct FindStationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FindStationResponse, 0, sizeof(struct FindStationResponse), 0, soap_copy_FindStationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strIPAddress > 0 || soap_flag_strStationName > 0 || soap_flag_strStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_FindStationResponse(struct soap *soap, const struct FindStationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FindStationResponse);
	if (soap_out_FindStationResponse(soap, tag?tag:"FindStationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct FindStationResponse * SOAP_FMAC4 soap_get_FindStationResponse(struct soap *soap, struct FindStationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_FindStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct FindStationResponse * SOAP_FMAC2 soap_instantiate_FindStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_FindStationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FindStationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct FindStationResponse);
		if (size)
			*size = sizeof(struct FindStationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct FindStationResponse, n);
		if (size)
			*size = n * sizeof(struct FindStationResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct FindStationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_FindStationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct FindStationResponse %p -> %p\n", q, p));
	*(struct FindStationResponse*)p = *(struct FindStationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fsreq__FindStationRequest(struct soap *soap, struct fsreq__FindStationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__fsreq_FindStationRequest(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fsreq__FindStationRequest(struct soap *soap, const struct fsreq__FindStationRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__fsreq_FindStationRequest(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fsreq__FindStationRequest(struct soap *soap, const char *tag, int id, const struct fsreq__FindStationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fsreq__FindStationRequest), type))
		return soap->error;
	if (soap_out__fsreq_FindStationRequest(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fsreq__FindStationRequest * SOAP_FMAC4 soap_in_fsreq__FindStationRequest(struct soap *soap, const char *tag, struct fsreq__FindStationRequest *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fsreq__FindStationRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fsreq__FindStationRequest, sizeof(struct fsreq__FindStationRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fsreq__FindStationRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__fsreq_FindStationRequest(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fsreq__FindStationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fsreq__FindStationRequest, 0, sizeof(struct fsreq__FindStationRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fsreq__FindStationRequest(struct soap *soap, const struct fsreq__FindStationRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fsreq__FindStationRequest);
	if (soap_out_fsreq__FindStationRequest(soap, tag?tag:"fsreq:FindStationRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct fsreq__FindStationRequest * SOAP_FMAC4 soap_get_fsreq__FindStationRequest(struct soap *soap, struct fsreq__FindStationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_fsreq__FindStationRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct fsreq__FindStationRequest * SOAP_FMAC2 soap_instantiate_fsreq__FindStationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fsreq__FindStationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fsreq__FindStationRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct fsreq__FindStationRequest);
		if (size)
			*size = sizeof(struct fsreq__FindStationRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct fsreq__FindStationRequest, n);
		if (size)
			*size = n * sizeof(struct fsreq__FindStationRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct fsreq__FindStationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fsreq__FindStationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fsreq__FindStationRequest %p -> %p\n", q, p));
	*(struct fsreq__FindStationRequest*)p = *(struct fsreq__FindStationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_FindStationRequest(struct soap *soap, struct FindStationRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->bDummy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_FindStationRequest(struct soap *soap, const struct FindStationRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_FindStationRequest(struct soap *soap, const char *tag, int id, const struct FindStationRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FindStationRequest), type))
		return soap->error;
	if (soap_out_bool(soap, "bDummy", -1, &a->bDummy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct FindStationRequest * SOAP_FMAC4 soap_in_FindStationRequest(struct soap *soap, const char *tag, struct FindStationRequest *a, const char *type)
{
	size_t soap_flag_bDummy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct FindStationRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FindStationRequest, sizeof(struct FindStationRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_FindStationRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bDummy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDummy", &a->bDummy, "xsd:boolean"))
				{	soap_flag_bDummy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct FindStationRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FindStationRequest, 0, sizeof(struct FindStationRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bDummy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_FindStationRequest(struct soap *soap, const struct FindStationRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FindStationRequest);
	if (soap_out_FindStationRequest(soap, tag?tag:"FindStationRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct FindStationRequest * SOAP_FMAC4 soap_get_FindStationRequest(struct soap *soap, struct FindStationRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_FindStationRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct FindStationRequest * SOAP_FMAC2 soap_instantiate_FindStationRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_FindStationRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FindStationRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct FindStationRequest);
		if (size)
			*size = sizeof(struct FindStationRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct FindStationRequest, n);
		if (size)
			*size = n * sizeof(struct FindStationRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct FindStationRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_FindStationRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct FindStationRequest %p -> %p\n", q, p));
	*(struct FindStationRequest*)p = *(struct FindStationRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rlres__CReadLogResponse(struct soap *soap, struct rlres__CReadLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_._rlres__CReadLogResponse::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rlres__CReadLogResponse(struct soap *soap, const struct rlres__CReadLogResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rlres__CReadLogResponse(struct soap *soap, const char *tag, int id, const struct rlres__CReadLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rlres__CReadLogResponse), type))
		return soap->error;
	if (a->return_.soap_out(soap, "return", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rlres__CReadLogResponse * SOAP_FMAC4 soap_in_rlres__CReadLogResponse(struct soap *soap, const char *tag, struct rlres__CReadLogResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rlres__CReadLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_rlres__CReadLogResponse, sizeof(struct rlres__CReadLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_rlres__CReadLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (a->return_.soap_in(soap, "return", ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rlres__CReadLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rlres__CReadLogResponse, 0, sizeof(struct rlres__CReadLogResponse), 0, soap_copy_rlres__CReadLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rlres__CReadLogResponse(struct soap *soap, const struct rlres__CReadLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rlres__CReadLogResponse);
	if (soap_out_rlres__CReadLogResponse(soap, tag?tag:"rlres:CReadLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rlres__CReadLogResponse * SOAP_FMAC4 soap_get_rlres__CReadLogResponse(struct soap *soap, struct rlres__CReadLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rlres__CReadLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct rlres__CReadLogResponse * SOAP_FMAC2 soap_instantiate_rlres__CReadLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_rlres__CReadLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_rlres__CReadLogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct rlres__CReadLogResponse);
		if (size)
			*size = sizeof(struct rlres__CReadLogResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct rlres__CReadLogResponse, n);
		if (size)
			*size = n * sizeof(struct rlres__CReadLogResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct rlres__CReadLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_rlres__CReadLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct rlres__CReadLogResponse %p -> %p\n", q, p));
	*(struct rlres__CReadLogResponse*)p = *(struct rlres__CReadLogResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ReadLogResponse(struct soap *soap, struct ReadLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &a->strDate);
	soap_default_std__wstring(soap, &a->strTime);
	soap_default_std__wstring(soap, &a->strLevel);
	soap_default_std__wstring(soap, &a->strFuncName);
	soap_default_std__wstring(soap, &a->strMessage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ReadLogResponse(struct soap *soap, const struct ReadLogResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__wstring(soap, &a->strDate);
	soap_serialize_std__wstring(soap, &a->strTime);
	soap_serialize_std__wstring(soap, &a->strLevel);
	soap_serialize_std__wstring(soap, &a->strFuncName);
	soap_serialize_std__wstring(soap, &a->strMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ReadLogResponse(struct soap *soap, const char *tag, int id, const struct ReadLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ReadLogResponse), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "strDate", -1, &a->strDate, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strTime", -1, &a->strTime, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strLevel", -1, &a->strLevel, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strFuncName", -1, &a->strFuncName, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strMessage", -1, &a->strMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ReadLogResponse * SOAP_FMAC4 soap_in_ReadLogResponse(struct soap *soap, const char *tag, struct ReadLogResponse *a, const char *type)
{
	size_t soap_flag_strDate = 1;
	size_t soap_flag_strTime = 1;
	size_t soap_flag_strLevel = 1;
	size_t soap_flag_strFuncName = 1;
	size_t soap_flag_strMessage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ReadLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ReadLogResponse, sizeof(struct ReadLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ReadLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strDate", &a->strDate, "xsd:string"))
				{	soap_flag_strDate--;
					continue;
				}
			if (soap_flag_strTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strTime", &a->strTime, "xsd:string"))
				{	soap_flag_strTime--;
					continue;
				}
			if (soap_flag_strLevel && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strLevel", &a->strLevel, "xsd:string"))
				{	soap_flag_strLevel--;
					continue;
				}
			if (soap_flag_strFuncName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strFuncName", &a->strFuncName, "xsd:string"))
				{	soap_flag_strFuncName--;
					continue;
				}
			if (soap_flag_strMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strMessage", &a->strMessage, "xsd:string"))
				{	soap_flag_strMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ReadLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ReadLogResponse, 0, sizeof(struct ReadLogResponse), 0, soap_copy_ReadLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strDate > 0 || soap_flag_strTime > 0 || soap_flag_strLevel > 0 || soap_flag_strFuncName > 0 || soap_flag_strMessage > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ReadLogResponse(struct soap *soap, const struct ReadLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ReadLogResponse);
	if (soap_out_ReadLogResponse(soap, tag?tag:"ReadLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ReadLogResponse * SOAP_FMAC4 soap_get_ReadLogResponse(struct soap *soap, struct ReadLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ReadLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ReadLogResponse * SOAP_FMAC2 soap_instantiate_ReadLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ReadLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ReadLogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ReadLogResponse);
		if (size)
			*size = sizeof(struct ReadLogResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ReadLogResponse, n);
		if (size)
			*size = n * sizeof(struct ReadLogResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ReadLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ReadLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ReadLogResponse %p -> %p\n", q, p));
	*(struct ReadLogResponse*)p = *(struct ReadLogResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rlreq__ReadLogRequest(struct soap *soap, struct rlreq__ReadLogRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__rlreq_ReadLogRequest(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rlreq__ReadLogRequest(struct soap *soap, const struct rlreq__ReadLogRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__rlreq_ReadLogRequest(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rlreq__ReadLogRequest(struct soap *soap, const char *tag, int id, const struct rlreq__ReadLogRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rlreq__ReadLogRequest), type))
		return soap->error;
	if (soap_out__rlreq_ReadLogRequest(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rlreq__ReadLogRequest * SOAP_FMAC4 soap_in_rlreq__ReadLogRequest(struct soap *soap, const char *tag, struct rlreq__ReadLogRequest *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rlreq__ReadLogRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_rlreq__ReadLogRequest, sizeof(struct rlreq__ReadLogRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_rlreq__ReadLogRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__rlreq_ReadLogRequest(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rlreq__ReadLogRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rlreq__ReadLogRequest, 0, sizeof(struct rlreq__ReadLogRequest), 0, soap_copy_rlreq__ReadLogRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rlreq__ReadLogRequest(struct soap *soap, const struct rlreq__ReadLogRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rlreq__ReadLogRequest);
	if (soap_out_rlreq__ReadLogRequest(soap, tag?tag:"rlreq:ReadLogRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rlreq__ReadLogRequest * SOAP_FMAC4 soap_get_rlreq__ReadLogRequest(struct soap *soap, struct rlreq__ReadLogRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_rlreq__ReadLogRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct rlreq__ReadLogRequest * SOAP_FMAC2 soap_instantiate_rlreq__ReadLogRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_rlreq__ReadLogRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_rlreq__ReadLogRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct rlreq__ReadLogRequest);
		if (size)
			*size = sizeof(struct rlreq__ReadLogRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct rlreq__ReadLogRequest, n);
		if (size)
			*size = n * sizeof(struct rlreq__ReadLogRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct rlreq__ReadLogRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_rlreq__ReadLogRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct rlreq__ReadLogRequest %p -> %p\n", q, p));
	*(struct rlreq__ReadLogRequest*)p = *(struct rlreq__ReadLogRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ReadLogRequest(struct soap *soap, struct ReadLogRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &a->strAETitle);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ReadLogRequest(struct soap *soap, const struct ReadLogRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__wstring(soap, &a->strAETitle);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ReadLogRequest(struct soap *soap, const char *tag, int id, const struct ReadLogRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ReadLogRequest), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "strAETitle", -1, &a->strAETitle, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ReadLogRequest * SOAP_FMAC4 soap_in_ReadLogRequest(struct soap *soap, const char *tag, struct ReadLogRequest *a, const char *type)
{
	size_t soap_flag_strAETitle = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ReadLogRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ReadLogRequest, sizeof(struct ReadLogRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ReadLogRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strAETitle && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strAETitle", &a->strAETitle, "xsd:string"))
				{	soap_flag_strAETitle--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ReadLogRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ReadLogRequest, 0, sizeof(struct ReadLogRequest), 0, soap_copy_ReadLogRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strAETitle > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ReadLogRequest(struct soap *soap, const struct ReadLogRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ReadLogRequest);
	if (soap_out_ReadLogRequest(soap, tag?tag:"ReadLogRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ReadLogRequest * SOAP_FMAC4 soap_get_ReadLogRequest(struct soap *soap, struct ReadLogRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ReadLogRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ReadLogRequest * SOAP_FMAC2 soap_instantiate_ReadLogRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ReadLogRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ReadLogRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ReadLogRequest);
		if (size)
			*size = sizeof(struct ReadLogRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ReadLogRequest, n);
		if (size)
			*size = n * sizeof(struct ReadLogRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ReadLogRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ReadLogRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ReadLogRequest %p -> %p\n", q, p));
	*(struct ReadLogRequest*)p = *(struct ReadLogRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wlres__WriteLogResponse(struct soap *soap, struct wlres__WriteLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wlres_WriteLogResponse(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wlres__WriteLogResponse(struct soap *soap, const struct wlres__WriteLogResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wlres_WriteLogResponse(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wlres__WriteLogResponse(struct soap *soap, const char *tag, int id, const struct wlres__WriteLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wlres__WriteLogResponse), type))
		return soap->error;
	if (soap_out__wlres_WriteLogResponse(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wlres__WriteLogResponse * SOAP_FMAC4 soap_in_wlres__WriteLogResponse(struct soap *soap, const char *tag, struct wlres__WriteLogResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wlres__WriteLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wlres__WriteLogResponse, sizeof(struct wlres__WriteLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wlres__WriteLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wlres_WriteLogResponse(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wlres__WriteLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wlres__WriteLogResponse, 0, sizeof(struct wlres__WriteLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wlres__WriteLogResponse(struct soap *soap, const struct wlres__WriteLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wlres__WriteLogResponse);
	if (soap_out_wlres__WriteLogResponse(soap, tag?tag:"wlres:WriteLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wlres__WriteLogResponse * SOAP_FMAC4 soap_get_wlres__WriteLogResponse(struct soap *soap, struct wlres__WriteLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_wlres__WriteLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wlres__WriteLogResponse * SOAP_FMAC2 soap_instantiate_wlres__WriteLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wlres__WriteLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wlres__WriteLogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wlres__WriteLogResponse);
		if (size)
			*size = sizeof(struct wlres__WriteLogResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wlres__WriteLogResponse, n);
		if (size)
			*size = n * sizeof(struct wlres__WriteLogResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wlres__WriteLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wlres__WriteLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wlres__WriteLogResponse %p -> %p\n", q, p));
	*(struct wlres__WriteLogResponse*)p = *(struct wlres__WriteLogResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_WriteLogResponse(struct soap *soap, struct WriteLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->bDummy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_WriteLogResponse(struct soap *soap, const struct WriteLogResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WriteLogResponse(struct soap *soap, const char *tag, int id, const struct WriteLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WriteLogResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "bDummy", -1, &a->bDummy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct WriteLogResponse * SOAP_FMAC4 soap_in_WriteLogResponse(struct soap *soap, const char *tag, struct WriteLogResponse *a, const char *type)
{
	size_t soap_flag_bDummy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct WriteLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_WriteLogResponse, sizeof(struct WriteLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_WriteLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bDummy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDummy", &a->bDummy, "xsd:boolean"))
				{	soap_flag_bDummy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct WriteLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_WriteLogResponse, 0, sizeof(struct WriteLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bDummy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_WriteLogResponse(struct soap *soap, const struct WriteLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_WriteLogResponse);
	if (soap_out_WriteLogResponse(soap, tag?tag:"WriteLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct WriteLogResponse * SOAP_FMAC4 soap_get_WriteLogResponse(struct soap *soap, struct WriteLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WriteLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct WriteLogResponse * SOAP_FMAC2 soap_instantiate_WriteLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WriteLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WriteLogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct WriteLogResponse);
		if (size)
			*size = sizeof(struct WriteLogResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct WriteLogResponse, n);
		if (size)
			*size = n * sizeof(struct WriteLogResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct WriteLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WriteLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct WriteLogResponse %p -> %p\n", q, p));
	*(struct WriteLogResponse*)p = *(struct WriteLogResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wlreq__WriteLogRequest(struct soap *soap, struct wlreq__WriteLogRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wlreq_WriteLogRequest(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wlreq__WriteLogRequest(struct soap *soap, const struct wlreq__WriteLogRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wlreq_WriteLogRequest(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wlreq__WriteLogRequest(struct soap *soap, const char *tag, int id, const struct wlreq__WriteLogRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wlreq__WriteLogRequest), type))
		return soap->error;
	if (soap_out__wlreq_WriteLogRequest(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wlreq__WriteLogRequest * SOAP_FMAC4 soap_in_wlreq__WriteLogRequest(struct soap *soap, const char *tag, struct wlreq__WriteLogRequest *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wlreq__WriteLogRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wlreq__WriteLogRequest, sizeof(struct wlreq__WriteLogRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_wlreq__WriteLogRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wlreq_WriteLogRequest(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wlreq__WriteLogRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wlreq__WriteLogRequest, 0, sizeof(struct wlreq__WriteLogRequest), 0, soap_copy_wlreq__WriteLogRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wlreq__WriteLogRequest(struct soap *soap, const struct wlreq__WriteLogRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wlreq__WriteLogRequest);
	if (soap_out_wlreq__WriteLogRequest(soap, tag?tag:"wlreq:WriteLogRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wlreq__WriteLogRequest * SOAP_FMAC4 soap_get_wlreq__WriteLogRequest(struct soap *soap, struct wlreq__WriteLogRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_wlreq__WriteLogRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wlreq__WriteLogRequest * SOAP_FMAC2 soap_instantiate_wlreq__WriteLogRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wlreq__WriteLogRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wlreq__WriteLogRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wlreq__WriteLogRequest);
		if (size)
			*size = sizeof(struct wlreq__WriteLogRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wlreq__WriteLogRequest, n);
		if (size)
			*size = n * sizeof(struct wlreq__WriteLogRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wlreq__WriteLogRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wlreq__WriteLogRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wlreq__WriteLogRequest %p -> %p\n", q, p));
	*(struct wlreq__WriteLogRequest*)p = *(struct wlreq__WriteLogRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_WriteLogRequest(struct soap *soap, struct WriteLogRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &a->strAETitle);
	soap_default_std__wstring(soap, &a->strLog);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_WriteLogRequest(struct soap *soap, const struct WriteLogRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__wstring(soap, &a->strAETitle);
	soap_serialize_std__wstring(soap, &a->strLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WriteLogRequest(struct soap *soap, const char *tag, int id, const struct WriteLogRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WriteLogRequest), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "strAETitle", -1, &a->strAETitle, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strLog", -1, &a->strLog, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct WriteLogRequest * SOAP_FMAC4 soap_in_WriteLogRequest(struct soap *soap, const char *tag, struct WriteLogRequest *a, const char *type)
{
	size_t soap_flag_strAETitle = 1;
	size_t soap_flag_strLog = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct WriteLogRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WriteLogRequest, sizeof(struct WriteLogRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_WriteLogRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strAETitle && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strAETitle", &a->strAETitle, "xsd:string"))
				{	soap_flag_strAETitle--;
					continue;
				}
			if (soap_flag_strLog && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strLog", &a->strLog, "xsd:string"))
				{	soap_flag_strLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct WriteLogRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_WriteLogRequest, 0, sizeof(struct WriteLogRequest), 0, soap_copy_WriteLogRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strAETitle > 0 || soap_flag_strLog > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_WriteLogRequest(struct soap *soap, const struct WriteLogRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_WriteLogRequest);
	if (soap_out_WriteLogRequest(soap, tag?tag:"WriteLogRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct WriteLogRequest * SOAP_FMAC4 soap_get_WriteLogRequest(struct soap *soap, struct WriteLogRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_WriteLogRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct WriteLogRequest * SOAP_FMAC2 soap_instantiate_WriteLogRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WriteLogRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WriteLogRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct WriteLogRequest);
		if (size)
			*size = sizeof(struct WriteLogRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct WriteLogRequest, n);
		if (size)
			*size = n * sizeof(struct WriteLogRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct WriteLogRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WriteLogRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct WriteLogRequest %p -> %p\n", q, p));
	*(struct WriteLogRequest*)p = *(struct WriteLogRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_frres__FindReceiverResponse(struct soap *soap, struct frres__FindReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__frres_FindReceiverResponse(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_frres__FindReceiverResponse(struct soap *soap, const struct frres__FindReceiverResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__frres_FindReceiverResponse(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_frres__FindReceiverResponse(struct soap *soap, const char *tag, int id, const struct frres__FindReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_frres__FindReceiverResponse), type))
		return soap->error;
	if (soap_out__frres_FindReceiverResponse(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct frres__FindReceiverResponse * SOAP_FMAC4 soap_in_frres__FindReceiverResponse(struct soap *soap, const char *tag, struct frres__FindReceiverResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct frres__FindReceiverResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_frres__FindReceiverResponse, sizeof(struct frres__FindReceiverResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_frres__FindReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__frres_FindReceiverResponse(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct frres__FindReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_frres__FindReceiverResponse, 0, sizeof(struct frres__FindReceiverResponse), 0, soap_copy_frres__FindReceiverResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_frres__FindReceiverResponse(struct soap *soap, const struct frres__FindReceiverResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_frres__FindReceiverResponse);
	if (soap_out_frres__FindReceiverResponse(soap, tag?tag:"frres:FindReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct frres__FindReceiverResponse * SOAP_FMAC4 soap_get_frres__FindReceiverResponse(struct soap *soap, struct frres__FindReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_frres__FindReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct frres__FindReceiverResponse * SOAP_FMAC2 soap_instantiate_frres__FindReceiverResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_frres__FindReceiverResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_frres__FindReceiverResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct frres__FindReceiverResponse);
		if (size)
			*size = sizeof(struct frres__FindReceiverResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct frres__FindReceiverResponse, n);
		if (size)
			*size = n * sizeof(struct frres__FindReceiverResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct frres__FindReceiverResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_frres__FindReceiverResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct frres__FindReceiverResponse %p -> %p\n", q, p));
	*(struct frres__FindReceiverResponse*)p = *(struct frres__FindReceiverResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_FindReceiverResponse(struct soap *soap, struct FindReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__listTemplateOfstd__wstring(soap, &a->lstResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_FindReceiverResponse(struct soap *soap, const struct FindReceiverResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__listTemplateOfstd__wstring(soap, &a->lstResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_FindReceiverResponse(struct soap *soap, const char *tag, int id, const struct FindReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FindReceiverResponse), type))
		return soap->error;
	if (soap_out_std__listTemplateOfstd__wstring(soap, "lstResponse", -1, &a->lstResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct FindReceiverResponse * SOAP_FMAC4 soap_in_FindReceiverResponse(struct soap *soap, const char *tag, struct FindReceiverResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct FindReceiverResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_FindReceiverResponse, sizeof(struct FindReceiverResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_FindReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__listTemplateOfstd__wstring(soap, "lstResponse", &a->lstResponse, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct FindReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FindReceiverResponse, 0, sizeof(struct FindReceiverResponse), 0, soap_copy_FindReceiverResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_FindReceiverResponse(struct soap *soap, const struct FindReceiverResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FindReceiverResponse);
	if (soap_out_FindReceiverResponse(soap, tag?tag:"FindReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct FindReceiverResponse * SOAP_FMAC4 soap_get_FindReceiverResponse(struct soap *soap, struct FindReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_FindReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct FindReceiverResponse * SOAP_FMAC2 soap_instantiate_FindReceiverResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_FindReceiverResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FindReceiverResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct FindReceiverResponse);
		if (size)
			*size = sizeof(struct FindReceiverResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct FindReceiverResponse, n);
		if (size)
			*size = n * sizeof(struct FindReceiverResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct FindReceiverResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_FindReceiverResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct FindReceiverResponse %p -> %p\n", q, p));
	*(struct FindReceiverResponse*)p = *(struct FindReceiverResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_frreq__FindReceiverRequest(struct soap *soap, struct frreq__FindReceiverRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__frreq_FindReceiverRequest(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_frreq__FindReceiverRequest(struct soap *soap, const struct frreq__FindReceiverRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__frreq_FindReceiverRequest(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_frreq__FindReceiverRequest(struct soap *soap, const char *tag, int id, const struct frreq__FindReceiverRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_frreq__FindReceiverRequest), type))
		return soap->error;
	if (soap_out__frreq_FindReceiverRequest(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct frreq__FindReceiverRequest * SOAP_FMAC4 soap_in_frreq__FindReceiverRequest(struct soap *soap, const char *tag, struct frreq__FindReceiverRequest *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct frreq__FindReceiverRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_frreq__FindReceiverRequest, sizeof(struct frreq__FindReceiverRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_frreq__FindReceiverRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__frreq_FindReceiverRequest(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct frreq__FindReceiverRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_frreq__FindReceiverRequest, 0, sizeof(struct frreq__FindReceiverRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_frreq__FindReceiverRequest(struct soap *soap, const struct frreq__FindReceiverRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_frreq__FindReceiverRequest);
	if (soap_out_frreq__FindReceiverRequest(soap, tag?tag:"frreq:FindReceiverRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct frreq__FindReceiverRequest * SOAP_FMAC4 soap_get_frreq__FindReceiverRequest(struct soap *soap, struct frreq__FindReceiverRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_frreq__FindReceiverRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct frreq__FindReceiverRequest * SOAP_FMAC2 soap_instantiate_frreq__FindReceiverRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_frreq__FindReceiverRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_frreq__FindReceiverRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct frreq__FindReceiverRequest);
		if (size)
			*size = sizeof(struct frreq__FindReceiverRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct frreq__FindReceiverRequest, n);
		if (size)
			*size = n * sizeof(struct frreq__FindReceiverRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct frreq__FindReceiverRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_frreq__FindReceiverRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct frreq__FindReceiverRequest %p -> %p\n", q, p));
	*(struct frreq__FindReceiverRequest*)p = *(struct frreq__FindReceiverRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_FindReceiverRequest(struct soap *soap, struct FindReceiverRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->bDummy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_FindReceiverRequest(struct soap *soap, const struct FindReceiverRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_FindReceiverRequest(struct soap *soap, const char *tag, int id, const struct FindReceiverRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FindReceiverRequest), type))
		return soap->error;
	if (soap_out_bool(soap, "bDummy", -1, &a->bDummy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct FindReceiverRequest * SOAP_FMAC4 soap_in_FindReceiverRequest(struct soap *soap, const char *tag, struct FindReceiverRequest *a, const char *type)
{
	size_t soap_flag_bDummy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct FindReceiverRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FindReceiverRequest, sizeof(struct FindReceiverRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_FindReceiverRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bDummy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDummy", &a->bDummy, "xsd:boolean"))
				{	soap_flag_bDummy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct FindReceiverRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FindReceiverRequest, 0, sizeof(struct FindReceiverRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bDummy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_FindReceiverRequest(struct soap *soap, const struct FindReceiverRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FindReceiverRequest);
	if (soap_out_FindReceiverRequest(soap, tag?tag:"FindReceiverRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct FindReceiverRequest * SOAP_FMAC4 soap_get_FindReceiverRequest(struct soap *soap, struct FindReceiverRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_FindReceiverRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct FindReceiverRequest * SOAP_FMAC2 soap_instantiate_FindReceiverRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_FindReceiverRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FindReceiverRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct FindReceiverRequest);
		if (size)
			*size = sizeof(struct FindReceiverRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct FindReceiverRequest, n);
		if (size)
			*size = n * sizeof(struct FindReceiverRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct FindReceiverRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_FindReceiverRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct FindReceiverRequest %p -> %p\n", q, p));
	*(struct FindReceiverRequest*)p = *(struct FindReceiverRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rres__RefreshResponse(struct soap *soap, struct rres__RefreshResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__rres_RefreshResponse(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rres__RefreshResponse(struct soap *soap, const struct rres__RefreshResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__rres_RefreshResponse(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rres__RefreshResponse(struct soap *soap, const char *tag, int id, const struct rres__RefreshResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rres__RefreshResponse), type))
		return soap->error;
	if (soap_out__rres_RefreshResponse(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rres__RefreshResponse * SOAP_FMAC4 soap_in_rres__RefreshResponse(struct soap *soap, const char *tag, struct rres__RefreshResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rres__RefreshResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rres__RefreshResponse, sizeof(struct rres__RefreshResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rres__RefreshResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__rres_RefreshResponse(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rres__RefreshResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rres__RefreshResponse, 0, sizeof(struct rres__RefreshResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rres__RefreshResponse(struct soap *soap, const struct rres__RefreshResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rres__RefreshResponse);
	if (soap_out_rres__RefreshResponse(soap, tag?tag:"rres:RefreshResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rres__RefreshResponse * SOAP_FMAC4 soap_get_rres__RefreshResponse(struct soap *soap, struct rres__RefreshResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rres__RefreshResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct rres__RefreshResponse * SOAP_FMAC2 soap_instantiate_rres__RefreshResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_rres__RefreshResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_rres__RefreshResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct rres__RefreshResponse);
		if (size)
			*size = sizeof(struct rres__RefreshResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct rres__RefreshResponse, n);
		if (size)
			*size = n * sizeof(struct rres__RefreshResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct rres__RefreshResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_rres__RefreshResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct rres__RefreshResponse %p -> %p\n", q, p));
	*(struct rres__RefreshResponse*)p = *(struct rres__RefreshResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_RefreshResponse(struct soap *soap, struct RefreshResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->bDummy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_RefreshResponse(struct soap *soap, const struct RefreshResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_RefreshResponse(struct soap *soap, const char *tag, int id, const struct RefreshResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RefreshResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "bDummy", -1, &a->bDummy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct RefreshResponse * SOAP_FMAC4 soap_in_RefreshResponse(struct soap *soap, const char *tag, struct RefreshResponse *a, const char *type)
{
	size_t soap_flag_bDummy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct RefreshResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RefreshResponse, sizeof(struct RefreshResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_RefreshResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bDummy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDummy", &a->bDummy, "xsd:boolean"))
				{	soap_flag_bDummy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct RefreshResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RefreshResponse, 0, sizeof(struct RefreshResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bDummy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_RefreshResponse(struct soap *soap, const struct RefreshResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RefreshResponse);
	if (soap_out_RefreshResponse(soap, tag?tag:"RefreshResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct RefreshResponse * SOAP_FMAC4 soap_get_RefreshResponse(struct soap *soap, struct RefreshResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_RefreshResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct RefreshResponse * SOAP_FMAC2 soap_instantiate_RefreshResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_RefreshResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RefreshResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct RefreshResponse);
		if (size)
			*size = sizeof(struct RefreshResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct RefreshResponse, n);
		if (size)
			*size = n * sizeof(struct RefreshResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct RefreshResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_RefreshResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct RefreshResponse %p -> %p\n", q, p));
	*(struct RefreshResponse*)p = *(struct RefreshResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rreq__RefreshRequest(struct soap *soap, struct rreq__RefreshRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__rreq_RefresRequest(soap, &a->retrun_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rreq__RefreshRequest(struct soap *soap, const struct rreq__RefreshRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__rreq_RefresRequest(soap, &a->retrun_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rreq__RefreshRequest(struct soap *soap, const char *tag, int id, const struct rreq__RefreshRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rreq__RefreshRequest), type))
		return soap->error;
	if (soap_out__rreq_RefresRequest(soap, "retrun", -1, &a->retrun_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rreq__RefreshRequest * SOAP_FMAC4 soap_in_rreq__RefreshRequest(struct soap *soap, const char *tag, struct rreq__RefreshRequest *a, const char *type)
{
	size_t soap_flag_retrun_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rreq__RefreshRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rreq__RefreshRequest, sizeof(struct rreq__RefreshRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rreq__RefreshRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_retrun_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__rreq_RefresRequest(soap, "retrun", &a->retrun_, ""))
				{	soap_flag_retrun_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rreq__RefreshRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rreq__RefreshRequest, 0, sizeof(struct rreq__RefreshRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retrun_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rreq__RefreshRequest(struct soap *soap, const struct rreq__RefreshRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rreq__RefreshRequest);
	if (soap_out_rreq__RefreshRequest(soap, tag?tag:"rreq:RefreshRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rreq__RefreshRequest * SOAP_FMAC4 soap_get_rreq__RefreshRequest(struct soap *soap, struct rreq__RefreshRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_rreq__RefreshRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct rreq__RefreshRequest * SOAP_FMAC2 soap_instantiate_rreq__RefreshRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_rreq__RefreshRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_rreq__RefreshRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct rreq__RefreshRequest);
		if (size)
			*size = sizeof(struct rreq__RefreshRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct rreq__RefreshRequest, n);
		if (size)
			*size = n * sizeof(struct rreq__RefreshRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct rreq__RefreshRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_rreq__RefreshRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct rreq__RefreshRequest %p -> %p\n", q, p));
	*(struct rreq__RefreshRequest*)p = *(struct rreq__RefreshRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_RefresRequest(struct soap *soap, struct RefresRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->nInterval);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_RefresRequest(struct soap *soap, const struct RefresRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_RefresRequest(struct soap *soap, const char *tag, int id, const struct RefresRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_RefresRequest), type))
		return soap->error;
	if (soap_out_int(soap, "nInterval", -1, &a->nInterval, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct RefresRequest * SOAP_FMAC4 soap_in_RefresRequest(struct soap *soap, const char *tag, struct RefresRequest *a, const char *type)
{
	size_t soap_flag_nInterval = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct RefresRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RefresRequest, sizeof(struct RefresRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_RefresRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nInterval", &a->nInterval, "xsd:int"))
				{	soap_flag_nInterval--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct RefresRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RefresRequest, 0, sizeof(struct RefresRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nInterval > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_RefresRequest(struct soap *soap, const struct RefresRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_RefresRequest);
	if (soap_out_RefresRequest(soap, tag?tag:"RefresRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct RefresRequest * SOAP_FMAC4 soap_get_RefresRequest(struct soap *soap, struct RefresRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_RefresRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct RefresRequest * SOAP_FMAC2 soap_instantiate_RefresRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_RefresRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_RefresRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct RefresRequest);
		if (size)
			*size = sizeof(struct RefresRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct RefresRequest, n);
		if (size)
			*size = n * sizeof(struct RefresRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct RefresRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_RefresRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct RefresRequest %p -> %p\n", q, p));
	*(struct RefresRequest*)p = *(struct RefresRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rres__CReadResponse(struct soap *soap, struct rres__CReadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_._rres__CReadResponse::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rres__CReadResponse(struct soap *soap, const struct rres__CReadResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rres__CReadResponse(struct soap *soap, const char *tag, int id, const struct rres__CReadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rres__CReadResponse), type))
		return soap->error;
	if (a->return_.soap_out(soap, "return", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rres__CReadResponse * SOAP_FMAC4 soap_in_rres__CReadResponse(struct soap *soap, const char *tag, struct rres__CReadResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rres__CReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_rres__CReadResponse, sizeof(struct rres__CReadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_rres__CReadResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (a->return_.soap_in(soap, "return", ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rres__CReadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rres__CReadResponse, 0, sizeof(struct rres__CReadResponse), 0, soap_copy_rres__CReadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rres__CReadResponse(struct soap *soap, const struct rres__CReadResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rres__CReadResponse);
	if (soap_out_rres__CReadResponse(soap, tag?tag:"rres:CReadResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rres__CReadResponse * SOAP_FMAC4 soap_get_rres__CReadResponse(struct soap *soap, struct rres__CReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rres__CReadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct rres__CReadResponse * SOAP_FMAC2 soap_instantiate_rres__CReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_rres__CReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_rres__CReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct rres__CReadResponse);
		if (size)
			*size = sizeof(struct rres__CReadResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct rres__CReadResponse, n);
		if (size)
			*size = n * sizeof(struct rres__CReadResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct rres__CReadResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_rres__CReadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct rres__CReadResponse %p -> %p\n", q, p));
	*(struct rres__CReadResponse*)p = *(struct rres__CReadResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rres__ReadResponse(struct soap *soap, struct rres__ReadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__rres__ReadResponse(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rres__ReadResponse(struct soap *soap, const struct rres__ReadResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__rres__ReadResponse(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rres__ReadResponse(struct soap *soap, const char *tag, int id, const struct rres__ReadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rres__ReadResponse), type))
		return soap->error;
	if (soap_out__rres__ReadResponse(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rres__ReadResponse * SOAP_FMAC4 soap_in_rres__ReadResponse(struct soap *soap, const char *tag, struct rres__ReadResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rres__ReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_rres__ReadResponse, sizeof(struct rres__ReadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_rres__ReadResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__rres__ReadResponse(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rres__ReadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rres__ReadResponse, 0, sizeof(struct rres__ReadResponse), 0, soap_copy_rres__ReadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rres__ReadResponse(struct soap *soap, const struct rres__ReadResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rres__ReadResponse);
	if (soap_out_rres__ReadResponse(soap, tag?tag:"rres:ReadResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rres__ReadResponse * SOAP_FMAC4 soap_get_rres__ReadResponse(struct soap *soap, struct rres__ReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rres__ReadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct rres__ReadResponse * SOAP_FMAC2 soap_instantiate_rres__ReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_rres__ReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_rres__ReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct rres__ReadResponse);
		if (size)
			*size = sizeof(struct rres__ReadResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct rres__ReadResponse, n);
		if (size)
			*size = n * sizeof(struct rres__ReadResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct rres__ReadResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_rres__ReadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct rres__ReadResponse %p -> %p\n", q, p));
	*(struct rres__ReadResponse*)p = *(struct rres__ReadResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ReadResponse(struct soap *soap, struct ReadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &a->strCallingAETtile);
	soap_default_std__wstring(soap, &a->strCalledAETitle);
	soap_default_std__wstring(soap, &a->strPatientID);
	soap_default_std__wstring(soap, &a->strPatientName);
	soap_default_std__wstring(soap, &a->strProtocol);
	soap_default_std__wstring(soap, &a->strSOPClassName);
	soap_default_int(soap, &a->nNumOfInstance);
	soap_default__hangpacs__Processing(soap, &a->eStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ReadResponse(struct soap *soap, const struct ReadResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__wstring(soap, &a->strCallingAETtile);
	soap_serialize_std__wstring(soap, &a->strCalledAETitle);
	soap_serialize_std__wstring(soap, &a->strPatientID);
	soap_serialize_std__wstring(soap, &a->strPatientName);
	soap_serialize_std__wstring(soap, &a->strProtocol);
	soap_serialize_std__wstring(soap, &a->strSOPClassName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ReadResponse(struct soap *soap, const char *tag, int id, const struct ReadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ReadResponse), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "strCallingAETtile", -1, &a->strCallingAETtile, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strCalledAETitle", -1, &a->strCalledAETitle, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strPatientID", -1, &a->strPatientID, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strPatientName", -1, &a->strPatientName, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strProtocol", -1, &a->strProtocol, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strSOPClassName", -1, &a->strSOPClassName, ""))
		return soap->error;
	if (soap_out_int(soap, "nNumOfInstance", -1, &a->nNumOfInstance, ""))
		return soap->error;
	if (soap_out__hangpacs__Processing(soap, "eStatus", -1, &a->eStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ReadResponse * SOAP_FMAC4 soap_in_ReadResponse(struct soap *soap, const char *tag, struct ReadResponse *a, const char *type)
{
	size_t soap_flag_strCallingAETtile = 1;
	size_t soap_flag_strCalledAETitle = 1;
	size_t soap_flag_strPatientID = 1;
	size_t soap_flag_strPatientName = 1;
	size_t soap_flag_strProtocol = 1;
	size_t soap_flag_strSOPClassName = 1;
	size_t soap_flag_nNumOfInstance = 1;
	size_t soap_flag_eStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ReadResponse, sizeof(struct ReadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ReadResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strCallingAETtile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strCallingAETtile", &a->strCallingAETtile, "xsd:string"))
				{	soap_flag_strCallingAETtile--;
					continue;
				}
			if (soap_flag_strCalledAETitle && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strCalledAETitle", &a->strCalledAETitle, "xsd:string"))
				{	soap_flag_strCalledAETitle--;
					continue;
				}
			if (soap_flag_strPatientID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strPatientID", &a->strPatientID, "xsd:string"))
				{	soap_flag_strPatientID--;
					continue;
				}
			if (soap_flag_strPatientName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strPatientName", &a->strPatientName, "xsd:string"))
				{	soap_flag_strPatientName--;
					continue;
				}
			if (soap_flag_strProtocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strProtocol", &a->strProtocol, "xsd:string"))
				{	soap_flag_strProtocol--;
					continue;
				}
			if (soap_flag_strSOPClassName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strSOPClassName", &a->strSOPClassName, "xsd:string"))
				{	soap_flag_strSOPClassName--;
					continue;
				}
			if (soap_flag_nNumOfInstance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nNumOfInstance", &a->nNumOfInstance, "xsd:int"))
				{	soap_flag_nNumOfInstance--;
					continue;
				}
			if (soap_flag_eStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__hangpacs__Processing(soap, "eStatus", &a->eStatus, ""))
				{	soap_flag_eStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ReadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ReadResponse, 0, sizeof(struct ReadResponse), 0, soap_copy_ReadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strCallingAETtile > 0 || soap_flag_strCalledAETitle > 0 || soap_flag_strPatientID > 0 || soap_flag_strPatientName > 0 || soap_flag_strProtocol > 0 || soap_flag_strSOPClassName > 0 || soap_flag_nNumOfInstance > 0 || soap_flag_eStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ReadResponse(struct soap *soap, const struct ReadResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ReadResponse);
	if (soap_out_ReadResponse(soap, tag?tag:"ReadResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ReadResponse * SOAP_FMAC4 soap_get_ReadResponse(struct soap *soap, struct ReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ReadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ReadResponse * SOAP_FMAC2 soap_instantiate_ReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ReadResponse);
		if (size)
			*size = sizeof(struct ReadResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ReadResponse, n);
		if (size)
			*size = n * sizeof(struct ReadResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ReadResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ReadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ReadResponse %p -> %p\n", q, p));
	*(struct ReadResponse*)p = *(struct ReadResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rreq__ReadRequest(struct soap *soap, struct rreq__ReadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__rreq__ReadRequest(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rreq__ReadRequest(struct soap *soap, const struct rreq__ReadRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__rreq__ReadRequest(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rreq__ReadRequest(struct soap *soap, const char *tag, int id, const struct rreq__ReadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rreq__ReadRequest), type))
		return soap->error;
	if (soap_out__rreq__ReadRequest(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rreq__ReadRequest * SOAP_FMAC4 soap_in_rreq__ReadRequest(struct soap *soap, const char *tag, struct rreq__ReadRequest *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rreq__ReadRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rreq__ReadRequest, sizeof(struct rreq__ReadRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rreq__ReadRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__rreq__ReadRequest(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rreq__ReadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rreq__ReadRequest, 0, sizeof(struct rreq__ReadRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rreq__ReadRequest(struct soap *soap, const struct rreq__ReadRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rreq__ReadRequest);
	if (soap_out_rreq__ReadRequest(soap, tag?tag:"rreq:ReadRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rreq__ReadRequest * SOAP_FMAC4 soap_get_rreq__ReadRequest(struct soap *soap, struct rreq__ReadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_rreq__ReadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct rreq__ReadRequest * SOAP_FMAC2 soap_instantiate_rreq__ReadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_rreq__ReadRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_rreq__ReadRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct rreq__ReadRequest);
		if (size)
			*size = sizeof(struct rreq__ReadRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct rreq__ReadRequest, n);
		if (size)
			*size = n * sizeof(struct rreq__ReadRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct rreq__ReadRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_rreq__ReadRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct rreq__ReadRequest %p -> %p\n", q, p));
	*(struct rreq__ReadRequest*)p = *(struct rreq__ReadRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ReadRequest(struct soap *soap, struct ReadRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->bDummy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ReadRequest(struct soap *soap, const struct ReadRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ReadRequest(struct soap *soap, const char *tag, int id, const struct ReadRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ReadRequest), type))
		return soap->error;
	if (soap_out_bool(soap, "bDummy", -1, &a->bDummy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ReadRequest * SOAP_FMAC4 soap_in_ReadRequest(struct soap *soap, const char *tag, struct ReadRequest *a, const char *type)
{
	size_t soap_flag_bDummy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ReadRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ReadRequest, sizeof(struct ReadRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ReadRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bDummy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDummy", &a->bDummy, "xsd:boolean"))
				{	soap_flag_bDummy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ReadRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ReadRequest, 0, sizeof(struct ReadRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bDummy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ReadRequest(struct soap *soap, const struct ReadRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ReadRequest);
	if (soap_out_ReadRequest(soap, tag?tag:"ReadRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ReadRequest * SOAP_FMAC4 soap_get_ReadRequest(struct soap *soap, struct ReadRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ReadRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ReadRequest * SOAP_FMAC2 soap_instantiate_ReadRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ReadRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ReadRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ReadRequest);
		if (size)
			*size = sizeof(struct ReadRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ReadRequest, n);
		if (size)
			*size = n * sizeof(struct ReadRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ReadRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ReadRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ReadRequest %p -> %p\n", q, p));
	*(struct ReadRequest*)p = *(struct ReadRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wres__WriteResponse(struct soap *soap, struct wres__WriteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wres__WriteResponse(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wres__WriteResponse(struct soap *soap, const struct wres__WriteResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wres__WriteResponse(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wres__WriteResponse(struct soap *soap, const char *tag, int id, const struct wres__WriteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wres__WriteResponse), type))
		return soap->error;
	if (soap_out__wres__WriteResponse(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wres__WriteResponse * SOAP_FMAC4 soap_in_wres__WriteResponse(struct soap *soap, const char *tag, struct wres__WriteResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wres__WriteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wres__WriteResponse, sizeof(struct wres__WriteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wres__WriteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wres__WriteResponse(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wres__WriteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wres__WriteResponse, 0, sizeof(struct wres__WriteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wres__WriteResponse(struct soap *soap, const struct wres__WriteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wres__WriteResponse);
	if (soap_out_wres__WriteResponse(soap, tag?tag:"wres:WriteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wres__WriteResponse * SOAP_FMAC4 soap_get_wres__WriteResponse(struct soap *soap, struct wres__WriteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_wres__WriteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wres__WriteResponse * SOAP_FMAC2 soap_instantiate_wres__WriteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wres__WriteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wres__WriteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wres__WriteResponse);
		if (size)
			*size = sizeof(struct wres__WriteResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wres__WriteResponse, n);
		if (size)
			*size = n * sizeof(struct wres__WriteResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wres__WriteResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wres__WriteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wres__WriteResponse %p -> %p\n", q, p));
	*(struct wres__WriteResponse*)p = *(struct wres__WriteResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_WriteResponse(struct soap *soap, struct WriteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->bDummy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_WriteResponse(struct soap *soap, const struct WriteResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WriteResponse(struct soap *soap, const char *tag, int id, const struct WriteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WriteResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "bDummy", -1, &a->bDummy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct WriteResponse * SOAP_FMAC4 soap_in_WriteResponse(struct soap *soap, const char *tag, struct WriteResponse *a, const char *type)
{
	size_t soap_flag_bDummy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct WriteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_WriteResponse, sizeof(struct WriteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_WriteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bDummy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDummy", &a->bDummy, "xsd:boolean"))
				{	soap_flag_bDummy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct WriteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_WriteResponse, 0, sizeof(struct WriteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bDummy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_WriteResponse(struct soap *soap, const struct WriteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_WriteResponse);
	if (soap_out_WriteResponse(soap, tag?tag:"WriteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct WriteResponse * SOAP_FMAC4 soap_get_WriteResponse(struct soap *soap, struct WriteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WriteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct WriteResponse * SOAP_FMAC2 soap_instantiate_WriteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WriteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WriteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct WriteResponse);
		if (size)
			*size = sizeof(struct WriteResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct WriteResponse, n);
		if (size)
			*size = n * sizeof(struct WriteResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct WriteResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WriteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct WriteResponse %p -> %p\n", q, p));
	*(struct WriteResponse*)p = *(struct WriteResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wreq__WriteRequest(struct soap *soap, struct wreq__WriteRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wreq__WriteRequest(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wreq__WriteRequest(struct soap *soap, const struct wreq__WriteRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wreq__WriteRequest(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wreq__WriteRequest(struct soap *soap, const char *tag, int id, const struct wreq__WriteRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wreq__WriteRequest), type))
		return soap->error;
	if (soap_out__wreq__WriteRequest(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wreq__WriteRequest * SOAP_FMAC4 soap_in_wreq__WriteRequest(struct soap *soap, const char *tag, struct wreq__WriteRequest *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wreq__WriteRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wreq__WriteRequest, sizeof(struct wreq__WriteRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_wreq__WriteRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wreq__WriteRequest(soap, "return", &a->return_, ""))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wreq__WriteRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wreq__WriteRequest, 0, sizeof(struct wreq__WriteRequest), 0, soap_copy_wreq__WriteRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wreq__WriteRequest(struct soap *soap, const struct wreq__WriteRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wreq__WriteRequest);
	if (soap_out_wreq__WriteRequest(soap, tag?tag:"wreq:WriteRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wreq__WriteRequest * SOAP_FMAC4 soap_get_wreq__WriteRequest(struct soap *soap, struct wreq__WriteRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_wreq__WriteRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wreq__WriteRequest * SOAP_FMAC2 soap_instantiate_wreq__WriteRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wreq__WriteRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wreq__WriteRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wreq__WriteRequest);
		if (size)
			*size = sizeof(struct wreq__WriteRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wreq__WriteRequest, n);
		if (size)
			*size = n * sizeof(struct wreq__WriteRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wreq__WriteRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wreq__WriteRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wreq__WriteRequest %p -> %p\n", q, p));
	*(struct wreq__WriteRequest*)p = *(struct wreq__WriteRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_WriteRequest(struct soap *soap, struct WriteRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &a->strCallingAETtile);
	soap_default_std__wstring(soap, &a->strCalledAETitle);
	soap_default_std__wstring(soap, &a->strPatientID);
	soap_default_std__wstring(soap, &a->strPatientName);
	soap_default_std__wstring(soap, &a->strProtocol);
	soap_default_std__wstring(soap, &a->strSOPClassName);
	soap_default_int(soap, &a->nNumOfInstance);
	soap_default__hangpacs__Processing(soap, &a->eStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_WriteRequest(struct soap *soap, const struct WriteRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__wstring(soap, &a->strCallingAETtile);
	soap_serialize_std__wstring(soap, &a->strCalledAETitle);
	soap_serialize_std__wstring(soap, &a->strPatientID);
	soap_serialize_std__wstring(soap, &a->strPatientName);
	soap_serialize_std__wstring(soap, &a->strProtocol);
	soap_serialize_std__wstring(soap, &a->strSOPClassName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WriteRequest(struct soap *soap, const char *tag, int id, const struct WriteRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WriteRequest), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "strCallingAETtile", -1, &a->strCallingAETtile, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strCalledAETitle", -1, &a->strCalledAETitle, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strPatientID", -1, &a->strPatientID, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strPatientName", -1, &a->strPatientName, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strProtocol", -1, &a->strProtocol, ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "strSOPClassName", -1, &a->strSOPClassName, ""))
		return soap->error;
	if (soap_out_int(soap, "nNumOfInstance", -1, &a->nNumOfInstance, ""))
		return soap->error;
	if (soap_out__hangpacs__Processing(soap, "eStatus", -1, &a->eStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct WriteRequest * SOAP_FMAC4 soap_in_WriteRequest(struct soap *soap, const char *tag, struct WriteRequest *a, const char *type)
{
	size_t soap_flag_strCallingAETtile = 1;
	size_t soap_flag_strCalledAETitle = 1;
	size_t soap_flag_strPatientID = 1;
	size_t soap_flag_strPatientName = 1;
	size_t soap_flag_strProtocol = 1;
	size_t soap_flag_strSOPClassName = 1;
	size_t soap_flag_nNumOfInstance = 1;
	size_t soap_flag_eStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct WriteRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WriteRequest, sizeof(struct WriteRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_WriteRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strCallingAETtile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strCallingAETtile", &a->strCallingAETtile, "xsd:string"))
				{	soap_flag_strCallingAETtile--;
					continue;
				}
			if (soap_flag_strCalledAETitle && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strCalledAETitle", &a->strCalledAETitle, "xsd:string"))
				{	soap_flag_strCalledAETitle--;
					continue;
				}
			if (soap_flag_strPatientID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strPatientID", &a->strPatientID, "xsd:string"))
				{	soap_flag_strPatientID--;
					continue;
				}
			if (soap_flag_strPatientName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strPatientName", &a->strPatientName, "xsd:string"))
				{	soap_flag_strPatientName--;
					continue;
				}
			if (soap_flag_strProtocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strProtocol", &a->strProtocol, "xsd:string"))
				{	soap_flag_strProtocol--;
					continue;
				}
			if (soap_flag_strSOPClassName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "strSOPClassName", &a->strSOPClassName, "xsd:string"))
				{	soap_flag_strSOPClassName--;
					continue;
				}
			if (soap_flag_nNumOfInstance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nNumOfInstance", &a->nNumOfInstance, "xsd:int"))
				{	soap_flag_nNumOfInstance--;
					continue;
				}
			if (soap_flag_eStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__hangpacs__Processing(soap, "eStatus", &a->eStatus, ""))
				{	soap_flag_eStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct WriteRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_WriteRequest, 0, sizeof(struct WriteRequest), 0, soap_copy_WriteRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strCallingAETtile > 0 || soap_flag_strCalledAETitle > 0 || soap_flag_strPatientID > 0 || soap_flag_strPatientName > 0 || soap_flag_strProtocol > 0 || soap_flag_strSOPClassName > 0 || soap_flag_nNumOfInstance > 0 || soap_flag_eStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_WriteRequest(struct soap *soap, const struct WriteRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_WriteRequest);
	if (soap_out_WriteRequest(soap, tag?tag:"WriteRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct WriteRequest * SOAP_FMAC4 soap_get_WriteRequest(struct soap *soap, struct WriteRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_WriteRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct WriteRequest * SOAP_FMAC2 soap_instantiate_WriteRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WriteRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WriteRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct WriteRequest);
		if (size)
			*size = sizeof(struct WriteRequest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct WriteRequest, n);
		if (size)
			*size = n * sizeof(struct WriteRequest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct WriteRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WriteRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct WriteRequest %p -> %p\n", q, p));
	*(struct WriteRequest*)p = *(struct WriteRequest*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocsres__CommandStationResponse(struct soap *soap, struct csres__CommandStationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_csres__CommandStationResponse))
		soap_serialize_csres__CommandStationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocsres__CommandStationResponse(struct soap *soap, const char *tag, int id, struct csres__CommandStationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_csres__CommandStationResponse);
	if (id < 0)
		return soap->error;
	return soap_out_csres__CommandStationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct csres__CommandStationResponse ** SOAP_FMAC4 soap_in_PointerTocsres__CommandStationResponse(struct soap *soap, const char *tag, struct csres__CommandStationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct csres__CommandStationResponse **)soap_malloc(soap, sizeof(struct csres__CommandStationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_csres__CommandStationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct csres__CommandStationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_csres__CommandStationResponse, sizeof(struct csres__CommandStationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocsres__CommandStationResponse(struct soap *soap, struct csres__CommandStationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocsres__CommandStationResponse);
	if (soap_out_PointerTocsres__CommandStationResponse(soap, tag?tag:"csres:CommandStationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct csres__CommandStationResponse ** SOAP_FMAC4 soap_get_PointerTocsres__CommandStationResponse(struct soap *soap, struct csres__CommandStationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocsres__CommandStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofsres__CFindStationResponse(struct soap *soap, struct fsres__CFindStationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fsres__CFindStationResponse))
		soap_serialize_fsres__CFindStationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofsres__CFindStationResponse(struct soap *soap, const char *tag, int id, struct fsres__CFindStationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fsres__CFindStationResponse);
	if (id < 0)
		return soap->error;
	return soap_out_fsres__CFindStationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct fsres__CFindStationResponse ** SOAP_FMAC4 soap_in_PointerTofsres__CFindStationResponse(struct soap *soap, const char *tag, struct fsres__CFindStationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct fsres__CFindStationResponse **)soap_malloc(soap, sizeof(struct fsres__CFindStationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fsres__CFindStationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct fsres__CFindStationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fsres__CFindStationResponse, sizeof(struct fsres__CFindStationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofsres__CFindStationResponse(struct soap *soap, struct fsres__CFindStationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofsres__CFindStationResponse);
	if (soap_out_PointerTofsres__CFindStationResponse(soap, tag?tag:"fsres:CFindStationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct fsres__CFindStationResponse ** SOAP_FMAC4 soap_get_PointerTofsres__CFindStationResponse(struct soap *soap, struct fsres__CFindStationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofsres__CFindStationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorlres__CReadLogResponse(struct soap *soap, struct rlres__CReadLogResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_rlres__CReadLogResponse))
		soap_serialize_rlres__CReadLogResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorlres__CReadLogResponse(struct soap *soap, const char *tag, int id, struct rlres__CReadLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rlres__CReadLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rlres__CReadLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rlres__CReadLogResponse ** SOAP_FMAC4 soap_in_PointerTorlres__CReadLogResponse(struct soap *soap, const char *tag, struct rlres__CReadLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rlres__CReadLogResponse **)soap_malloc(soap, sizeof(struct rlres__CReadLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rlres__CReadLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rlres__CReadLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rlres__CReadLogResponse, sizeof(struct rlres__CReadLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorlres__CReadLogResponse(struct soap *soap, struct rlres__CReadLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorlres__CReadLogResponse);
	if (soap_out_PointerTorlres__CReadLogResponse(soap, tag?tag:"rlres:CReadLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rlres__CReadLogResponse ** SOAP_FMAC4 soap_get_PointerTorlres__CReadLogResponse(struct soap *soap, struct rlres__CReadLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorlres__CReadLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowlres__WriteLogResponse(struct soap *soap, struct wlres__WriteLogResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wlres__WriteLogResponse))
		soap_serialize_wlres__WriteLogResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowlres__WriteLogResponse(struct soap *soap, const char *tag, int id, struct wlres__WriteLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wlres__WriteLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out_wlres__WriteLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wlres__WriteLogResponse ** SOAP_FMAC4 soap_in_PointerTowlres__WriteLogResponse(struct soap *soap, const char *tag, struct wlres__WriteLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wlres__WriteLogResponse **)soap_malloc(soap, sizeof(struct wlres__WriteLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wlres__WriteLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wlres__WriteLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wlres__WriteLogResponse, sizeof(struct wlres__WriteLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowlres__WriteLogResponse(struct soap *soap, struct wlres__WriteLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowlres__WriteLogResponse);
	if (soap_out_PointerTowlres__WriteLogResponse(soap, tag?tag:"wlres:WriteLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wlres__WriteLogResponse ** SOAP_FMAC4 soap_get_PointerTowlres__WriteLogResponse(struct soap *soap, struct wlres__WriteLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowlres__WriteLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofrres__FindReceiverResponse(struct soap *soap, struct frres__FindReceiverResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_frres__FindReceiverResponse))
		soap_serialize_frres__FindReceiverResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofrres__FindReceiverResponse(struct soap *soap, const char *tag, int id, struct frres__FindReceiverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_frres__FindReceiverResponse);
	if (id < 0)
		return soap->error;
	return soap_out_frres__FindReceiverResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct frres__FindReceiverResponse ** SOAP_FMAC4 soap_in_PointerTofrres__FindReceiverResponse(struct soap *soap, const char *tag, struct frres__FindReceiverResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct frres__FindReceiverResponse **)soap_malloc(soap, sizeof(struct frres__FindReceiverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_frres__FindReceiverResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct frres__FindReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_frres__FindReceiverResponse, sizeof(struct frres__FindReceiverResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofrres__FindReceiverResponse(struct soap *soap, struct frres__FindReceiverResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofrres__FindReceiverResponse);
	if (soap_out_PointerTofrres__FindReceiverResponse(soap, tag?tag:"frres:FindReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct frres__FindReceiverResponse ** SOAP_FMAC4 soap_get_PointerTofrres__FindReceiverResponse(struct soap *soap, struct frres__FindReceiverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofrres__FindReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorres__RefreshResponse(struct soap *soap, struct rres__RefreshResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_rres__RefreshResponse))
		soap_serialize_rres__RefreshResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorres__RefreshResponse(struct soap *soap, const char *tag, int id, struct rres__RefreshResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rres__RefreshResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rres__RefreshResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rres__RefreshResponse ** SOAP_FMAC4 soap_in_PointerTorres__RefreshResponse(struct soap *soap, const char *tag, struct rres__RefreshResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rres__RefreshResponse **)soap_malloc(soap, sizeof(struct rres__RefreshResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rres__RefreshResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rres__RefreshResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rres__RefreshResponse, sizeof(struct rres__RefreshResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorres__RefreshResponse(struct soap *soap, struct rres__RefreshResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorres__RefreshResponse);
	if (soap_out_PointerTorres__RefreshResponse(soap, tag?tag:"rres:RefreshResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rres__RefreshResponse ** SOAP_FMAC4 soap_get_PointerTorres__RefreshResponse(struct soap *soap, struct rres__RefreshResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorres__RefreshResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorres__CReadResponse(struct soap *soap, struct rres__CReadResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_rres__CReadResponse))
		soap_serialize_rres__CReadResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorres__CReadResponse(struct soap *soap, const char *tag, int id, struct rres__CReadResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rres__CReadResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rres__CReadResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rres__CReadResponse ** SOAP_FMAC4 soap_in_PointerTorres__CReadResponse(struct soap *soap, const char *tag, struct rres__CReadResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rres__CReadResponse **)soap_malloc(soap, sizeof(struct rres__CReadResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rres__CReadResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rres__CReadResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rres__CReadResponse, sizeof(struct rres__CReadResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorres__CReadResponse(struct soap *soap, struct rres__CReadResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorres__CReadResponse);
	if (soap_out_PointerTorres__CReadResponse(soap, tag?tag:"rres:CReadResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct rres__CReadResponse ** SOAP_FMAC4 soap_get_PointerTorres__CReadResponse(struct soap *soap, struct rres__CReadResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorres__CReadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowres__WriteResponse(struct soap *soap, struct wres__WriteResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wres__WriteResponse))
		soap_serialize_wres__WriteResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowres__WriteResponse(struct soap *soap, const char *tag, int id, struct wres__WriteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wres__WriteResponse);
	if (id < 0)
		return soap->error;
	return soap_out_wres__WriteResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wres__WriteResponse ** SOAP_FMAC4 soap_in_PointerTowres__WriteResponse(struct soap *soap, const char *tag, struct wres__WriteResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wres__WriteResponse **)soap_malloc(soap, sizeof(struct wres__WriteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wres__WriteResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wres__WriteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wres__WriteResponse, sizeof(struct wres__WriteResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowres__WriteResponse(struct soap *soap, struct wres__WriteResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowres__WriteResponse);
	if (soap_out_PointerTowres__WriteResponse(soap, tag?tag:"wres:WriteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wres__WriteResponse ** SOAP_FMAC4 soap_get_PointerTowres__WriteResponse(struct soap *soap, struct wres__WriteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowres__WriteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__listTemplateOf_fsres_FindStationResponse(struct soap *soap, std::list<struct FindStationResponse >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__listTemplateOf_fsres_FindStationResponse(struct soap *soap, const std::list<struct FindStationResponse >*a)
{
#ifndef WITH_NOIDREF
	for (std::list<struct FindStationResponse >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize__fsres_FindStationResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__listTemplateOf_fsres_FindStationResponse(struct soap *soap, const char *tag, int id, const std::list<struct FindStationResponse >*a, const char *type)
{
	for (std::list<struct FindStationResponse >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out__fsres_FindStationResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::list<struct FindStationResponse >* SOAP_FMAC4 soap_in_std__listTemplateOf_fsres_FindStationResponse(struct soap *soap, const char *tag, std::list<struct FindStationResponse >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	struct FindStationResponse n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default__fsres_FindStationResponse(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__fsres_FindStationResponse, SOAP_TYPE_std__listTemplateOf_fsres_FindStationResponse, sizeof(struct FindStationResponse), 0))
				break;
			if (!soap_in__fsres_FindStationResponse(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__fsres_FindStationResponse(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__listTemplateOf_fsres_FindStationResponse(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::list<struct FindStationResponse > * SOAP_FMAC2 soap_instantiate_std__listTemplateOf_fsres_FindStationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__listTemplateOf_fsres_FindStationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__listTemplateOf_fsres_FindStationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::list<struct FindStationResponse >);
		if (size)
			*size = sizeof(std::list<struct FindStationResponse >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::list<struct FindStationResponse >, n);
		if (size)
			*size = n * sizeof(std::list<struct FindStationResponse >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::list<struct FindStationResponse >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__listTemplateOf_fsres_FindStationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::list<struct FindStationResponse > %p -> %p\n", q, p));
	*(std::list<struct FindStationResponse >*)p = *(std::list<struct FindStationResponse >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__listTemplateOf_rlres_ReadLogResponse(struct soap *soap, std::list<struct ReadLogResponse >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__listTemplateOf_rlres_ReadLogResponse(struct soap *soap, const std::list<struct ReadLogResponse >*a)
{
#ifndef WITH_NOIDREF
	for (std::list<struct ReadLogResponse >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize__rlres_ReadLogResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__listTemplateOf_rlres_ReadLogResponse(struct soap *soap, const char *tag, int id, const std::list<struct ReadLogResponse >*a, const char *type)
{
	for (std::list<struct ReadLogResponse >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out__rlres_ReadLogResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::list<struct ReadLogResponse >* SOAP_FMAC4 soap_in_std__listTemplateOf_rlres_ReadLogResponse(struct soap *soap, const char *tag, std::list<struct ReadLogResponse >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	struct ReadLogResponse n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default__rlres_ReadLogResponse(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__rlres_ReadLogResponse, SOAP_TYPE_std__listTemplateOf_rlres_ReadLogResponse, sizeof(struct ReadLogResponse), 0))
				break;
			if (!soap_in__rlres_ReadLogResponse(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__rlres_ReadLogResponse(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__listTemplateOf_rlres_ReadLogResponse(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::list<struct ReadLogResponse > * SOAP_FMAC2 soap_instantiate_std__listTemplateOf_rlres_ReadLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__listTemplateOf_rlres_ReadLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__listTemplateOf_rlres_ReadLogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::list<struct ReadLogResponse >);
		if (size)
			*size = sizeof(std::list<struct ReadLogResponse >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::list<struct ReadLogResponse >, n);
		if (size)
			*size = n * sizeof(std::list<struct ReadLogResponse >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::list<struct ReadLogResponse >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__listTemplateOf_rlres_ReadLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::list<struct ReadLogResponse > %p -> %p\n", q, p));
	*(std::list<struct ReadLogResponse >*)p = *(std::list<struct ReadLogResponse >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__listTemplateOfstd__wstring(struct soap *soap, std::list<std::wstring >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__listTemplateOfstd__wstring(struct soap *soap, const std::list<std::wstring >*a)
{
#ifndef WITH_NOIDREF
	for (std::list<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__wstring(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__listTemplateOfstd__wstring(struct soap *soap, const char *tag, int id, const std::list<std::wstring >*a, const char *type)
{
	for (std::list<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__wstring(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::list<std::wstring >* SOAP_FMAC4 soap_in_std__listTemplateOfstd__wstring(struct soap *soap, const char *tag, std::list<std::wstring >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::wstring n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_std__wstring(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__wstring, SOAP_TYPE_std__listTemplateOfstd__wstring, sizeof(std::wstring), 0))
				break;
			if (!soap_in_std__wstring(soap, tag, NULL, "xsd:string"))
				break;
		}
		else if (!soap_in_std__wstring(soap, tag, &n, "xsd:string"))
			break;
		if (!a && !(a = soap_new_std__listTemplateOfstd__wstring(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::list<std::wstring > * SOAP_FMAC2 soap_instantiate_std__listTemplateOfstd__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__listTemplateOfstd__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__listTemplateOfstd__wstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::list<std::wstring >);
		if (size)
			*size = sizeof(std::list<std::wstring >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::list<std::wstring >, n);
		if (size)
			*size = n * sizeof(std::list<std::wstring >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::list<std::wstring >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__listTemplateOfstd__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::list<std::wstring > %p -> %p\n", q, p));
	*(std::list<std::wstring >*)p = *(std::list<std::wstring >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__listTemplateOf_rres__ReadResponse(struct soap *soap, std::list<struct ReadResponse >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__listTemplateOf_rres__ReadResponse(struct soap *soap, const std::list<struct ReadResponse >*a)
{
#ifndef WITH_NOIDREF
	for (std::list<struct ReadResponse >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize__rres__ReadResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__listTemplateOf_rres__ReadResponse(struct soap *soap, const char *tag, int id, const std::list<struct ReadResponse >*a, const char *type)
{
	for (std::list<struct ReadResponse >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out__rres__ReadResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::list<struct ReadResponse >* SOAP_FMAC4 soap_in_std__listTemplateOf_rres__ReadResponse(struct soap *soap, const char *tag, std::list<struct ReadResponse >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	struct ReadResponse n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default__rres__ReadResponse(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__rres__ReadResponse, SOAP_TYPE_std__listTemplateOf_rres__ReadResponse, sizeof(struct ReadResponse), 0))
				break;
			if (!soap_in__rres__ReadResponse(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__rres__ReadResponse(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__listTemplateOf_rres__ReadResponse(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::list<struct ReadResponse > * SOAP_FMAC2 soap_instantiate_std__listTemplateOf_rres__ReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__listTemplateOf_rres__ReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__listTemplateOf_rres__ReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::list<struct ReadResponse >);
		if (size)
			*size = sizeof(std::list<struct ReadResponse >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::list<struct ReadResponse >, n);
		if (size)
			*size = n * sizeof(std::list<struct ReadResponse >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::list<struct ReadResponse >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__listTemplateOf_rres__ReadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::list<struct ReadResponse > %p -> %p\n", q, p));
	*(std::list<struct ReadResponse >*)p = *(std::list<struct ReadResponse >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
